/* tslint:disable */
/* eslint-disable */
/**
 * Halo Next API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface Apple
 */
export interface Apple {
  /**
   *
   * @type {AppleSpec}
   * @memberof Apple
   */
  spec?: AppleSpec
  /**
   *
   * @type {string}
   * @memberof Apple
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Apple
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Apple
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface AppleSpec
 */
export interface AppleSpec {
  /**
   *
   * @type {string}
   * @memberof AppleSpec
   */
  varieties: string
  /**
   *
   * @type {string}
   * @memberof AppleSpec
   */
  color?: string
  /**
   *
   * @type {string}
   * @memberof AppleSpec
   */
  size?: string
  /**
   *
   * @type {string}
   * @memberof AppleSpec
   */
  producingArea?: string
}
/**
 *
 * @export
 * @interface Author
 */
export interface Author {
  /**
   *
   * @type {string}
   * @memberof Author
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Author
   */
  website?: string
}
/**
 *
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
  /**
   * New password.
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface ConfigMap
 */
export interface ConfigMap {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ConfigMap
   */
  data?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ConfigMap
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ConfigMapList
 */
export interface ConfigMapList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ConfigMapList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ConfigMapList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ConfigMapList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<ConfigMap>}
   * @memberof ConfigMapList
   */
  items: Array<ConfigMap>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface FileReverseProxyProvider
 */
export interface FileReverseProxyProvider {
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  directory?: string
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  filename?: string
}
/**
 *
 * @export
 * @interface GrantRequest
 */
export interface GrantRequest {
  /**
   *
   * @type {Set<string>}
   * @memberof GrantRequest
   */
  roles?: Set<string>
}
/**
 *
 * @export
 * @interface License
 */
export interface License {
  /**
   *
   * @type {string}
   * @memberof License
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof License
   */
  url?: string
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {LinkSpec}
   * @memberof Link
   */
  spec?: LinkSpec
  /**
   *
   * @type {string}
   * @memberof Link
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Link
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface LinkGroup
 */
export interface LinkGroup {
  /**
   *
   * @type {LinkGroupSpec}
   * @memberof LinkGroup
   */
  spec?: LinkGroupSpec
  /**
   *
   * @type {string}
   * @memberof LinkGroup
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof LinkGroup
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof LinkGroup
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface LinkGroupSpec
 */
export interface LinkGroupSpec {
  /**
   *
   * @type {string}
   * @memberof LinkGroupSpec
   */
  displayName: string
  /**
   *
   * @type {number}
   * @memberof LinkGroupSpec
   */
  priority?: number
  /**
   * Names of links below this group.
   * @type {Set<string>}
   * @memberof LinkGroupSpec
   */
  links?: Set<string>
}
/**
 *
 * @export
 * @interface LinkSpec
 */
export interface LinkSpec {
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  url: string
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  logo?: string
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  description?: string
  /**
   *
   * @type {number}
   * @memberof LinkSpec
   */
  priority?: number
}
/**
 *
 * @export
 * @interface LoginHistory
 */
export interface LoginHistory {
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  loginAt: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  sourceIp: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  userAgent: string
  /**
   *
   * @type {boolean}
   * @memberof LoginHistory
   */
  successful: boolean
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  reason?: string
}
/**
 *
 * @export
 * @interface Menu
 */
export interface Menu {
  /**
   *
   * @type {MenuSpec}
   * @memberof Menu
   */
  spec: MenuSpec
  /**
   *
   * @type {string}
   * @memberof Menu
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Menu
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Menu
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface MenuItem
 */
export interface MenuItem {
  /**
   *
   * @type {MenuItemSpec}
   * @memberof MenuItem
   */
  spec: MenuItemSpec
  /**
   *
   * @type {MenuItemStatus}
   * @memberof MenuItem
   */
  status?: MenuItemStatus
  /**
   *
   * @type {string}
   * @memberof MenuItem
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof MenuItem
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof MenuItem
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface MenuItemList
 */
export interface MenuItemList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuItemList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuItemList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof MenuItemList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<MenuItem>}
   * @memberof MenuItemList
   */
  items: Array<MenuItem>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  hasPrevious: boolean
}
/**
 * Page reference.
 * @export
 * @interface MenuItemRef
 */
export interface MenuItemRef {
  /**
   * Reference name.
   * @type {string}
   * @memberof MenuItemRef
   */
  name: string
}
/**
 * The spec of menu item.
 * @export
 * @interface MenuItemSpec
 */
export interface MenuItemSpec {
  /**
   * The display name of menu item.
   * @type {string}
   * @memberof MenuItemSpec
   */
  displayName?: string
  /**
   * The href of this menu item.
   * @type {string}
   * @memberof MenuItemSpec
   */
  href?: string
  /**
   * The priority is for ordering.
   * @type {number}
   * @memberof MenuItemSpec
   */
  priority?: number
  /**
   * Children of this menu item
   * @type {Set<string>}
   * @memberof MenuItemSpec
   */
  children?: Set<string>
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  categoryRef?: MenuItemRef
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  tagRef?: MenuItemRef
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  postRef?: MenuItemRef
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  pageRef?: MenuItemRef
}
/**
 * The status of menu item.
 * @export
 * @interface MenuItemStatus
 */
export interface MenuItemStatus {
  /**
   * Calculated Display name of menu item.
   * @type {string}
   * @memberof MenuItemStatus
   */
  displayName?: string
  /**
   * Calculated href of manu item.
   * @type {string}
   * @memberof MenuItemStatus
   */
  href?: string
}
/**
 *
 * @export
 * @interface MenuList
 */
export interface MenuList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof MenuList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Menu>}
   * @memberof MenuList
   */
  items: Array<Menu>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof MenuList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof MenuList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuList
   */
  hasPrevious: boolean
}
/**
 * The spec of menu.
 * @export
 * @interface MenuSpec
 */
export interface MenuSpec {
  /**
   * The display name of the menu.
   * @type {string}
   * @memberof MenuSpec
   */
  displayName: string
  /**
   * Names of menu children below this menu.
   * @type {Set<string>}
   * @memberof MenuSpec
   */
  menuItems?: Set<string>
}
/**
 *
 * @export
 * @interface Metadata
 */
export interface Metadata {
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  name: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  labels?: { [key: string]: string } | null
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  annotations?: { [key: string]: string } | null
  /**
   *
   * @type {number}
   * @memberof Metadata
   */
  version?: number | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  creationTimestamp?: string | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  deletionTimestamp?: string | null
}
/**
 *
 * @export
 * @interface PersonalAccessToken
 */
export interface PersonalAccessToken {
  /**
   *
   * @type {PersonalAccessTokenSpec}
   * @memberof PersonalAccessToken
   */
  spec?: PersonalAccessTokenSpec
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof PersonalAccessToken
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PersonalAccessTokenList
 */
export interface PersonalAccessTokenList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<PersonalAccessToken>}
   * @memberof PersonalAccessTokenList
   */
  items: Array<PersonalAccessToken>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PersonalAccessTokenSpec
 */
export interface PersonalAccessTokenSpec {
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  userName?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  displayName?: string
  /**
   *
   * @type {boolean}
   * @memberof PersonalAccessTokenSpec
   */
  revoked?: boolean
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  expiresAt?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  scopes?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  tokenDigest?: string
}
/**
 *
 * @export
 * @interface Plugin
 */
export interface Plugin {
  /**
   *
   * @type {PluginSpec}
   * @memberof Plugin
   */
  spec: PluginSpec
  /**
   *
   * @type {PluginStatus}
   * @memberof Plugin
   */
  status?: PluginStatus
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Plugin
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PluginList
 */
export interface PluginList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PluginList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PluginList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PluginList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Plugin>}
   * @memberof PluginList
   */
  items: Array<Plugin>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PluginList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PluginList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PluginList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PluginList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PluginSpec
 */
export interface PluginSpec {
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  displayName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  version?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  author?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  logo?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PluginSpec
   */
  pluginDependencies?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  homepage?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  description?: string
  /**
   *
   * @type {Array<License>}
   * @memberof PluginSpec
   */
  license?: Array<License>
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  requires?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   * @deprecated
   */
  pluginClass?: string
  /**
   *
   * @type {boolean}
   * @memberof PluginSpec
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  settingName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  configMapName?: string
}
/**
 *
 * @export
 * @interface PluginStatus
 */
export interface PluginStatus {
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  phase?: PluginStatusPhaseEnum
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  reason?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastStartTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastTransitionTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  entry?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  stylesheet?: string
}

export const PluginStatusPhaseEnum = {
  Created: 'CREATED',
  Disabled: 'DISABLED',
  Resolved: 'RESOLVED',
  Started: 'STARTED',
  Stopped: 'STOPPED',
  Failed: 'FAILED',
} as const

export type PluginStatusPhaseEnum = typeof PluginStatusPhaseEnum[keyof typeof PluginStatusPhaseEnum]

/**
 *
 * @export
 * @interface PolicyRule
 */
export interface PolicyRule {
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  apiGroups?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resources?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resourceNames?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  nonResourceURLs?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  verbs?: Array<string>
}
/**
 *
 * @export
 * @interface ReverseProxy
 */
export interface ReverseProxy {
  /**
   *
   * @type {Array<ReverseProxyRule>}
   * @memberof ReverseProxy
   */
  rules?: Array<ReverseProxyRule>
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ReverseProxy
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ReverseProxyList
 */
export interface ReverseProxyList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReverseProxyList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReverseProxyList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ReverseProxyList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<ReverseProxy>}
   * @memberof ReverseProxyList
   */
  items: Array<ReverseProxy>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface ReverseProxyRule
 */
export interface ReverseProxyRule {
  /**
   *
   * @type {string}
   * @memberof ReverseProxyRule
   */
  path?: string
  /**
   *
   * @type {FileReverseProxyProvider}
   * @memberof ReverseProxyRule
   */
  file?: FileReverseProxyProvider
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {Array<PolicyRule>}
   * @memberof Role
   */
  rules: Array<PolicyRule>
  /**
   *
   * @type {string}
   * @memberof Role
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Role
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Role
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleBinding
 */
export interface RoleBinding {
  /**
   *
   * @type {Array<Subject>}
   * @memberof RoleBinding
   */
  subjects?: Array<Subject>
  /**
   *
   * @type {RoleRef}
   * @memberof RoleBinding
   */
  roleRef?: RoleRef
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof RoleBinding
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleBindingList
 */
export interface RoleBindingList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleBindingList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleBindingList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof RoleBindingList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<RoleBinding>}
   * @memberof RoleBindingList
   */
  items: Array<RoleBinding>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface RoleList
 */
export interface RoleList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof RoleList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Role>}
   * @memberof RoleList
   */
  items: Array<Role>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof RoleList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof RoleList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface RoleRef
 */
export interface RoleRef {
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
  /**
   *
   * @type {Array<SettingSpec>}
   * @memberof Setting
   */
  spec: Array<SettingSpec>
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Setting
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface SettingList
 */
export interface SettingList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SettingList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SettingList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof SettingList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Setting>}
   * @memberof SettingList
   */
  items: Array<Setting>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof SettingList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof SettingList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SettingList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SettingList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface SettingSpec
 */
export interface SettingSpec {
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  group: string
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  label?: string
  /**
   *
   * @type {Array<object>}
   * @memberof SettingSpec
   */
  formSchema?: Array<object>
}
/**
 *
 * @export
 * @interface Subject
 */
export interface Subject {
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface Theme
 */
export interface Theme {
  /**
   *
   * @type {ThemeSpec}
   * @memberof Theme
   */
  spec: ThemeSpec
  /**
   *
   * @type {string}
   * @memberof Theme
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Theme
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Theme
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ThemeList
 */
export interface ThemeList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ThemeList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ThemeList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ThemeList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Theme>}
   * @memberof ThemeList
   */
  items: Array<Theme>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ThemeList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ThemeList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ThemeList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ThemeList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface ThemeSpec
 */
export interface ThemeSpec {
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  displayName: string
  /**
   *
   * @type {Author}
   * @memberof ThemeSpec
   */
  author: Author
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  logo?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  website?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  repo?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  version: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  require: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  settingName?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  configMapName?: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {UserSpec}
   * @memberof User
   */
  spec: UserSpec
  /**
   *
   * @type {UserStatus}
   * @memberof User
   */
  status?: UserStatus
  /**
   *
   * @type {string}
   * @memberof User
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof User
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof UserList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof UserList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof UserList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<User>}
   * @memberof UserList
   */
  items: Array<User>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof UserList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof UserList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof UserList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof UserList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface UserPermission
 */
export interface UserPermission {
  /**
   *
   * @type {Set<Role>}
   * @memberof UserPermission
   */
  roles: Set<Role>
  /**
   *
   * @type {Set<string>}
   * @memberof UserPermission
   */
  uiPermissions: Set<string>
}
/**
 *
 * @export
 * @interface UserSpec
 */
export interface UserSpec {
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  avatar?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  bio?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  registeredAt?: string
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  twoFactorAuthEnabled?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  disabled?: boolean
  /**
   *
   * @type {number}
   * @memberof UserSpec
   */
  loginHistoryLimit?: number
}
/**
 *
 * @export
 * @interface UserStatus
 */
export interface UserStatus {
  /**
   *
   * @type {string}
   * @memberof UserStatus
   */
  lastLoginAt?: string
  /**
   *
   * @type {Array<LoginHistory>}
   * @memberof UserStatus
   */
  loginHistories?: Array<LoginHistory>
}

/**
 * ApiHaloRunV1alpha1PluginApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installPlugin: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('installPlugin', 'file', file)
      const localVarPath = `/apis/api.halo.run/v1alpha1/plugins/install`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1PluginApiAxiosParamCreator(configuration)
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async installPlugin(
      file: any,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.installPlugin(file, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1PluginApiFp(configuration)
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installPlugin(file: any, options?: any): AxiosPromise<void> {
      return localVarFp.installPlugin(file, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1PluginApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1PluginApi extends BaseAPI {
  /**
   * Install a plugin by uploading a Jar file.
   * @param {any} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1PluginApi
   */
  public installPlugin(file: any, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1PluginApiFp(this.configuration)
      .installPlugin(file, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Install a theme by uploading a zip file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installTheme: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('installTheme', 'file', file)
      const localVarPath = `/apis/api.halo.run/v1alpha1/themes/install`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1ThemeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1ThemeApiAxiosParamCreator(configuration)
  return {
    /**
     * Install a theme by uploading a zip file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async installTheme(
      file: any,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.installTheme(file, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1ThemeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1ThemeApiFp(configuration)
  return {
    /**
     * Install a theme by uploading a zip file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installTheme(file: any, options?: any): AxiosPromise<Theme> {
      return localVarFp.installTheme(file, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1ThemeApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1ThemeApi extends BaseAPI {
  /**
   * Install a theme by uploading a zip file.
   * @param {any} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1ThemeApi
   */
  public installTheme(file: any, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1ThemeApiFp(this.configuration)
      .installTheme(file, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      name: string,
      changePasswordRequest: ChangePasswordRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('changePassword', 'name', name)
      // verify required parameter 'changePasswordRequest' is not null or undefined
      assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/password`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/-`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getPermissions', 'name', name)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission: async (
      name: string,
      grantRequest: GrantRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('grantPermission', 'name', name)
      // verify required parameter 'grantRequest' is not null or undefined
      assertParamExists('grantPermission', 'grantRequest', grantRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(grantRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      name: string,
      changePasswordRequest: ChangePasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(name, changePasswordRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUserDetail(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserDetail(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPermissions(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPermission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissions(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grantPermission(
      name: string,
      grantRequest: GrantRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grantPermission(name, grantRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1UserApiFp(configuration)
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(name: string, changePasswordRequest: ChangePasswordRequest, options?: any): AxiosPromise<User> {
      return localVarFp.changePassword(name, changePasswordRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail(options?: any): AxiosPromise<User> {
      return localVarFp.getCurrentUserDetail(options).then((request) => request(axios, basePath))
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions(name: string, options?: any): AxiosPromise<UserPermission> {
      return localVarFp.getPermissions(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission(name: string, grantRequest: GrantRequest, options?: any): AxiosPromise<User> {
      return localVarFp.grantPermission(name, grantRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1UserApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1UserApi extends BaseAPI {
  /**
   * Change password of user.
   * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
   * @param {ChangePasswordRequest} changePasswordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public changePassword(name: string, changePasswordRequest: ChangePasswordRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .changePassword(name, changePasswordRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get current user detail
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getCurrentUserDetail(options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getCurrentUserDetail(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get permissions of user
   * @param {string} name User name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getPermissions(name: string, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getPermissions(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Grant permissions to user
   * @param {string} name User name
   * @param {GrantRequest} grantRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public grantPermission(name: string, grantRequest: GrantRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .grantPermission(name, grantRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApplesControllerApi - axios parameter creator
 * @export
 */
export const ApplesControllerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hello: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.api.halo.run/v1alpha1/plugins/PluginTemplate/apples`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApplesControllerApi - functional programming interface
 * @export
 */
export const ApplesControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApplesControllerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hello(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hello(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApplesControllerApi - factory interface
 * @export
 */
export const ApplesControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApplesControllerApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hello(options?: any): AxiosPromise<string> {
      return localVarFp.hello(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApplesControllerApi - object-oriented interface
 * @export
 * @class ApplesControllerApi
 * @extends {BaseAPI}
 */
export class ApplesControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplesControllerApi
   */
  public hello(options?: AxiosRequestConfig) {
    return ApplesControllerApiFp(this.configuration)
      .hello(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - axios parameter creator
 * @export
 */
export const CoreHaloRunV1alpha1LinkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create core.halo.run/v1alpha1/Link
     * @param {Link} [link] Fresh link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1Link: async (link?: Link, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/links`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(link, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1Link: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecoreHaloRunV1alpha1Link', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/links/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1Link: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcoreHaloRunV1alpha1Link', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/links/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List core.halo.run/v1alpha1/Link
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1Link: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/links`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {Link} [link] Updated link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1Link: async (
      name: string,
      link?: Link,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecoreHaloRunV1alpha1Link', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/links/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(link, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - functional programming interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CoreHaloRunV1alpha1LinkApiAxiosParamCreator(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/Link
     * @param {Link} [link] Fresh link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcoreHaloRunV1alpha1Link(
      link?: Link,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcoreHaloRunV1alpha1Link(link, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecoreHaloRunV1alpha1Link(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecoreHaloRunV1alpha1Link(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcoreHaloRunV1alpha1Link(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcoreHaloRunV1alpha1Link(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List core.halo.run/v1alpha1/Link
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcoreHaloRunV1alpha1Link(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcoreHaloRunV1alpha1Link(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {Link} [link] Updated link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecoreHaloRunV1alpha1Link(
      name: string,
      link?: Link,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecoreHaloRunV1alpha1Link(name, link, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - factory interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CoreHaloRunV1alpha1LinkApiFp(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/Link
     * @param {Link} [link] Fresh link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1Link(link?: Link, options?: any): AxiosPromise<Link> {
      return localVarFp.createcoreHaloRunV1alpha1Link(link, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1Link(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecoreHaloRunV1alpha1Link(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1Link(name: string, options?: any): AxiosPromise<Link> {
      return localVarFp.getcoreHaloRunV1alpha1Link(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List core.halo.run/v1alpha1/Link
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1Link(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .listcoreHaloRunV1alpha1Link(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {Link} [link] Updated link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1Link(name: string, link?: Link, options?: any): AxiosPromise<Link> {
      return localVarFp.updatecoreHaloRunV1alpha1Link(name, link, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - object-oriented interface
 * @export
 * @class CoreHaloRunV1alpha1LinkApi
 * @extends {BaseAPI}
 */
export class CoreHaloRunV1alpha1LinkApi extends BaseAPI {
  /**
   * Create core.halo.run/v1alpha1/Link
   * @param {Link} [link] Fresh link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public createcoreHaloRunV1alpha1Link(link?: Link, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .createcoreHaloRunV1alpha1Link(link, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete core.halo.run/v1alpha1/Link
   * @param {string} name Name of link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public deletecoreHaloRunV1alpha1Link(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .deletecoreHaloRunV1alpha1Link(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get core.halo.run/v1alpha1/Link
   * @param {string} name Name of link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public getcoreHaloRunV1alpha1Link(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .getcoreHaloRunV1alpha1Link(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List core.halo.run/v1alpha1/Link
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public listcoreHaloRunV1alpha1Link(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .listcoreHaloRunV1alpha1Link(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update core.halo.run/v1alpha1/Link
   * @param {string} name Name of link
   * @param {Link} [link] Updated link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public updatecoreHaloRunV1alpha1Link(name: string, link?: Link, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .updatecoreHaloRunV1alpha1Link(name, link, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - axios parameter creator
 * @export
 */
export const CoreHaloRunV1alpha1LinkGroupApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create core.halo.run/v1alpha1/LinkGroup
     * @param {LinkGroup} [linkGroup] Fresh linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1LinkGroup: async (
      linkGroup?: LinkGroup,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(linkGroup, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1LinkGroup: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecoreHaloRunV1alpha1LinkGroup', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1LinkGroup: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcoreHaloRunV1alpha1LinkGroup', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List core.halo.run/v1alpha1/LinkGroup
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1LinkGroup: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {LinkGroup} [linkGroup] Updated linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1LinkGroup: async (
      name: string,
      linkGroup?: LinkGroup,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecoreHaloRunV1alpha1LinkGroup', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(linkGroup, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - functional programming interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkGroupApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CoreHaloRunV1alpha1LinkGroupApiAxiosParamCreator(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/LinkGroup
     * @param {LinkGroup} [linkGroup] Fresh linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcoreHaloRunV1alpha1LinkGroup(
      linkGroup?: LinkGroup,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkGroup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcoreHaloRunV1alpha1LinkGroup(linkGroup, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecoreHaloRunV1alpha1LinkGroup(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecoreHaloRunV1alpha1LinkGroup(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcoreHaloRunV1alpha1LinkGroup(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkGroup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcoreHaloRunV1alpha1LinkGroup(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List core.halo.run/v1alpha1/LinkGroup
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcoreHaloRunV1alpha1LinkGroup(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcoreHaloRunV1alpha1LinkGroup(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {LinkGroup} [linkGroup] Updated linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecoreHaloRunV1alpha1LinkGroup(
      name: string,
      linkGroup?: LinkGroup,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkGroup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecoreHaloRunV1alpha1LinkGroup(
        name,
        linkGroup,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - factory interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkGroupApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CoreHaloRunV1alpha1LinkGroupApiFp(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/LinkGroup
     * @param {LinkGroup} [linkGroup] Fresh linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1LinkGroup(linkGroup?: LinkGroup, options?: any): AxiosPromise<LinkGroup> {
      return localVarFp
        .createcoreHaloRunV1alpha1LinkGroup(linkGroup, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1LinkGroup(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecoreHaloRunV1alpha1LinkGroup(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1LinkGroup(name: string, options?: any): AxiosPromise<LinkGroup> {
      return localVarFp.getcoreHaloRunV1alpha1LinkGroup(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List core.halo.run/v1alpha1/LinkGroup
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1LinkGroup(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .listcoreHaloRunV1alpha1LinkGroup(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {LinkGroup} [linkGroup] Updated linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1LinkGroup(name: string, linkGroup?: LinkGroup, options?: any): AxiosPromise<LinkGroup> {
      return localVarFp
        .updatecoreHaloRunV1alpha1LinkGroup(name, linkGroup, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - object-oriented interface
 * @export
 * @class CoreHaloRunV1alpha1LinkGroupApi
 * @extends {BaseAPI}
 */
export class CoreHaloRunV1alpha1LinkGroupApi extends BaseAPI {
  /**
   * Create core.halo.run/v1alpha1/LinkGroup
   * @param {LinkGroup} [linkGroup] Fresh linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public createcoreHaloRunV1alpha1LinkGroup(linkGroup?: LinkGroup, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .createcoreHaloRunV1alpha1LinkGroup(linkGroup, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete core.halo.run/v1alpha1/LinkGroup
   * @param {string} name Name of linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public deletecoreHaloRunV1alpha1LinkGroup(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .deletecoreHaloRunV1alpha1LinkGroup(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get core.halo.run/v1alpha1/LinkGroup
   * @param {string} name Name of linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public getcoreHaloRunV1alpha1LinkGroup(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .getcoreHaloRunV1alpha1LinkGroup(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List core.halo.run/v1alpha1/LinkGroup
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public listcoreHaloRunV1alpha1LinkGroup(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .listcoreHaloRunV1alpha1LinkGroup(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update core.halo.run/v1alpha1/LinkGroup
   * @param {string} name Name of linkgroup
   * @param {LinkGroup} [linkGroup] Updated linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public updatecoreHaloRunV1alpha1LinkGroup(name: string, linkGroup?: LinkGroup, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .updatecoreHaloRunV1alpha1LinkGroup(name, linkGroup, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin: async (
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin: async (
      name: string,
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1PluginApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1Plugin(
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1Plugin(plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1Plugin(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1Plugin(
      name: string,
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1PluginApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp.createpluginHaloRunV1alpha1Plugin(plugin, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletepluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<Plugin> {
      return localVarFp.getpluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<PluginList> {
      return localVarFp
        .listpluginHaloRunV1alpha1Plugin(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp
        .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1PluginApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1PluginApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/Plugin
   * @param {Plugin} [plugin] Fresh plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .createpluginHaloRunV1alpha1Plugin(plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public deletepluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public getpluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .getpluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/Plugin
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public listpluginHaloRunV1alpha1Plugin(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .listpluginHaloRunV1alpha1Plugin(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {Plugin} [plugin] Updated plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy: async (
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1ReverseProxy(
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1ReverseProxy(
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxyList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1ReverseProxy(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1ReverseProxy(
        name,
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1ReverseProxyApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp
        .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp.getpluginHaloRunV1alpha1ReverseProxy(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<ReverseProxyList> {
      return localVarFp
        .listpluginHaloRunV1alpha1ReverseProxy(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: any,
    ): AxiosPromise<ReverseProxy> {
      return localVarFp
        .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1ReverseProxyApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1ReverseProxyApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/ReverseProxy
   * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .getpluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/ReverseProxy
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public listpluginHaloRunV1alpha1ReverseProxy(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .listpluginHaloRunV1alpha1ReverseProxy(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public updatepluginHaloRunV1alpha1ReverseProxy(
    name: string,
    reverseProxy?: ReverseProxy,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RunHaloTemplateV1alpha1AppleApi - axios parameter creator
 * @export
 */
export const RunHaloTemplateV1alpha1AppleApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create run.halo.template/v1alpha1/Apple
     * @param {Apple} [apple] Fresh apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createrunHaloTemplateV1alpha1Apple: async (
      apple?: Apple,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/run.halo.template/v1alpha1/apples`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(apple, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleterunHaloTemplateV1alpha1Apple: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deleterunHaloTemplateV1alpha1Apple', 'name', name)
      const localVarPath = `/apis/run.halo.template/v1alpha1/apples/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getrunHaloTemplateV1alpha1Apple: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getrunHaloTemplateV1alpha1Apple', 'name', name)
      const localVarPath = `/apis/run.halo.template/v1alpha1/apples/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List run.halo.template/v1alpha1/Apple
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listrunHaloTemplateV1alpha1Apple: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/run.halo.template/v1alpha1/apples`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {Apple} [apple] Updated apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updaterunHaloTemplateV1alpha1Apple: async (
      name: string,
      apple?: Apple,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updaterunHaloTemplateV1alpha1Apple', 'name', name)
      const localVarPath = `/apis/run.halo.template/v1alpha1/apples/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(apple, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RunHaloTemplateV1alpha1AppleApi - functional programming interface
 * @export
 */
export const RunHaloTemplateV1alpha1AppleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RunHaloTemplateV1alpha1AppleApiAxiosParamCreator(configuration)
  return {
    /**
     * Create run.halo.template/v1alpha1/Apple
     * @param {Apple} [apple] Fresh apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createrunHaloTemplateV1alpha1Apple(
      apple?: Apple,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Apple>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createrunHaloTemplateV1alpha1Apple(apple, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleterunHaloTemplateV1alpha1Apple(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleterunHaloTemplateV1alpha1Apple(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getrunHaloTemplateV1alpha1Apple(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Apple>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getrunHaloTemplateV1alpha1Apple(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List run.halo.template/v1alpha1/Apple
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listrunHaloTemplateV1alpha1Apple(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listrunHaloTemplateV1alpha1Apple(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {Apple} [apple] Updated apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updaterunHaloTemplateV1alpha1Apple(
      name: string,
      apple?: Apple,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Apple>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updaterunHaloTemplateV1alpha1Apple(name, apple, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * RunHaloTemplateV1alpha1AppleApi - factory interface
 * @export
 */
export const RunHaloTemplateV1alpha1AppleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RunHaloTemplateV1alpha1AppleApiFp(configuration)
  return {
    /**
     * Create run.halo.template/v1alpha1/Apple
     * @param {Apple} [apple] Fresh apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createrunHaloTemplateV1alpha1Apple(apple?: Apple, options?: any): AxiosPromise<Apple> {
      return localVarFp.createrunHaloTemplateV1alpha1Apple(apple, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleterunHaloTemplateV1alpha1Apple(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deleterunHaloTemplateV1alpha1Apple(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getrunHaloTemplateV1alpha1Apple(name: string, options?: any): AxiosPromise<Apple> {
      return localVarFp.getrunHaloTemplateV1alpha1Apple(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List run.halo.template/v1alpha1/Apple
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listrunHaloTemplateV1alpha1Apple(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .listrunHaloTemplateV1alpha1Apple(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update run.halo.template/v1alpha1/Apple
     * @param {string} name Name of apple
     * @param {Apple} [apple] Updated apple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updaterunHaloTemplateV1alpha1Apple(name: string, apple?: Apple, options?: any): AxiosPromise<Apple> {
      return localVarFp
        .updaterunHaloTemplateV1alpha1Apple(name, apple, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RunHaloTemplateV1alpha1AppleApi - object-oriented interface
 * @export
 * @class RunHaloTemplateV1alpha1AppleApi
 * @extends {BaseAPI}
 */
export class RunHaloTemplateV1alpha1AppleApi extends BaseAPI {
  /**
   * Create run.halo.template/v1alpha1/Apple
   * @param {Apple} [apple] Fresh apple
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunHaloTemplateV1alpha1AppleApi
   */
  public createrunHaloTemplateV1alpha1Apple(apple?: Apple, options?: AxiosRequestConfig) {
    return RunHaloTemplateV1alpha1AppleApiFp(this.configuration)
      .createrunHaloTemplateV1alpha1Apple(apple, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete run.halo.template/v1alpha1/Apple
   * @param {string} name Name of apple
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunHaloTemplateV1alpha1AppleApi
   */
  public deleterunHaloTemplateV1alpha1Apple(name: string, options?: AxiosRequestConfig) {
    return RunHaloTemplateV1alpha1AppleApiFp(this.configuration)
      .deleterunHaloTemplateV1alpha1Apple(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get run.halo.template/v1alpha1/Apple
   * @param {string} name Name of apple
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunHaloTemplateV1alpha1AppleApi
   */
  public getrunHaloTemplateV1alpha1Apple(name: string, options?: AxiosRequestConfig) {
    return RunHaloTemplateV1alpha1AppleApiFp(this.configuration)
      .getrunHaloTemplateV1alpha1Apple(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List run.halo.template/v1alpha1/Apple
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunHaloTemplateV1alpha1AppleApi
   */
  public listrunHaloTemplateV1alpha1Apple(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return RunHaloTemplateV1alpha1AppleApiFp(this.configuration)
      .listrunHaloTemplateV1alpha1Apple(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update run.halo.template/v1alpha1/Apple
   * @param {string} name Name of apple
   * @param {Apple} [apple] Updated apple
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RunHaloTemplateV1alpha1AppleApi
   */
  public updaterunHaloTemplateV1alpha1Apple(name: string, apple?: Apple, options?: AxiosRequestConfig) {
    return RunHaloTemplateV1alpha1AppleApiFp(this.configuration)
      .updaterunHaloTemplateV1alpha1Apple(name, apple, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - axios parameter creator
 * @export
 */
export const ThemeHaloRunV1alpha1ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create theme.halo.run/v1alpha1/Theme
     * @param {Theme} [theme] Fresh theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createthemeHaloRunV1alpha1Theme: async (theme?: Theme, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(theme, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletethemeHaloRunV1alpha1Theme: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletethemeHaloRunV1alpha1Theme', 'name', name)
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getthemeHaloRunV1alpha1Theme: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getthemeHaloRunV1alpha1Theme', 'name', name)
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List theme.halo.run/v1alpha1/Theme
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listthemeHaloRunV1alpha1Theme: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {Theme} [theme] Updated theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatethemeHaloRunV1alpha1Theme: async (
      name: string,
      theme?: Theme,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatethemeHaloRunV1alpha1Theme', 'name', name)
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(theme, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - functional programming interface
 * @export
 */
export const ThemeHaloRunV1alpha1ThemeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ThemeHaloRunV1alpha1ThemeApiAxiosParamCreator(configuration)
  return {
    /**
     * Create theme.halo.run/v1alpha1/Theme
     * @param {Theme} [theme] Fresh theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createthemeHaloRunV1alpha1Theme(
      theme?: Theme,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createthemeHaloRunV1alpha1Theme(theme, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletethemeHaloRunV1alpha1Theme(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletethemeHaloRunV1alpha1Theme(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getthemeHaloRunV1alpha1Theme(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getthemeHaloRunV1alpha1Theme(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List theme.halo.run/v1alpha1/Theme
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listthemeHaloRunV1alpha1Theme(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listthemeHaloRunV1alpha1Theme(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {Theme} [theme] Updated theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatethemeHaloRunV1alpha1Theme(
      name: string,
      theme?: Theme,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatethemeHaloRunV1alpha1Theme(name, theme, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - factory interface
 * @export
 */
export const ThemeHaloRunV1alpha1ThemeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ThemeHaloRunV1alpha1ThemeApiFp(configuration)
  return {
    /**
     * Create theme.halo.run/v1alpha1/Theme
     * @param {Theme} [theme] Fresh theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createthemeHaloRunV1alpha1Theme(theme?: Theme, options?: any): AxiosPromise<Theme> {
      return localVarFp.createthemeHaloRunV1alpha1Theme(theme, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletethemeHaloRunV1alpha1Theme(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletethemeHaloRunV1alpha1Theme(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getthemeHaloRunV1alpha1Theme(name: string, options?: any): AxiosPromise<Theme> {
      return localVarFp.getthemeHaloRunV1alpha1Theme(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List theme.halo.run/v1alpha1/Theme
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listthemeHaloRunV1alpha1Theme(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<ThemeList> {
      return localVarFp
        .listthemeHaloRunV1alpha1Theme(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {Theme} [theme] Updated theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatethemeHaloRunV1alpha1Theme(name: string, theme?: Theme, options?: any): AxiosPromise<Theme> {
      return localVarFp
        .updatethemeHaloRunV1alpha1Theme(name, theme, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - object-oriented interface
 * @export
 * @class ThemeHaloRunV1alpha1ThemeApi
 * @extends {BaseAPI}
 */
export class ThemeHaloRunV1alpha1ThemeApi extends BaseAPI {
  /**
   * Create theme.halo.run/v1alpha1/Theme
   * @param {Theme} [theme] Fresh theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public createthemeHaloRunV1alpha1Theme(theme?: Theme, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .createthemeHaloRunV1alpha1Theme(theme, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete theme.halo.run/v1alpha1/Theme
   * @param {string} name Name of theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public deletethemeHaloRunV1alpha1Theme(name: string, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .deletethemeHaloRunV1alpha1Theme(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get theme.halo.run/v1alpha1/Theme
   * @param {string} name Name of theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public getthemeHaloRunV1alpha1Theme(name: string, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .getthemeHaloRunV1alpha1Theme(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List theme.halo.run/v1alpha1/Theme
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public listthemeHaloRunV1alpha1Theme(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .listthemeHaloRunV1alpha1Theme(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update theme.halo.run/v1alpha1/Theme
   * @param {string} name Name of theme
   * @param {Theme} [theme] Updated theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public updatethemeHaloRunV1alpha1Theme(name: string, theme?: Theme, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .updatethemeHaloRunV1alpha1Theme(name, theme, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1ConfigMapApi - axios parameter creator
 * @export
 */
export const V1alpha1ConfigMapApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap: async (configMap?: ConfigMap, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap: async (
      name: string,
      configMap?: ConfigMap,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1ConfigMapApi - functional programming interface
 * @export
 */
export const V1alpha1ConfigMapApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1ConfigMapApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1ConfigMap(
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1ConfigMap(configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1ConfigMap(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMapList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1ConfigMap(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1ConfigMap(
      name: string,
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1ConfigMap(name, configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1ConfigMapApi - factory interface
 * @export
 */
export const V1alpha1ConfigMapApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1ConfigMapApiFp(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap(configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.createv1alpha1ConfigMap(configMap, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap(name: string, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.getv1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<ConfigMapList> {
      return localVarFp
        .listv1alpha1ConfigMap(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.updatev1alpha1ConfigMap(name, configMap, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1ConfigMapApi - object-oriented interface
 * @export
 * @class V1alpha1ConfigMapApi
 * @extends {BaseAPI}
 */
export class V1alpha1ConfigMapApi extends BaseAPI {
  /**
   * Create v1alpha1/ConfigMap
   * @param {ConfigMap} [configMap] Fresh configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public createv1alpha1ConfigMap(configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .createv1alpha1ConfigMap(configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public deletev1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .deletev1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public getv1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .getv1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/ConfigMap
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public listv1alpha1ConfigMap(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .listv1alpha1ConfigMap(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {ConfigMap} [configMap] Updated configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .updatev1alpha1ConfigMap(name, configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1MenuApi - axios parameter creator
 * @export
 */
export const V1alpha1MenuApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Menu
     * @param {Menu} [menu] Fresh menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Menu: async (menu?: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menus`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Menu: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Menu', 'name', name)
      const localVarPath = `/api/v1alpha1/menus/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Menu: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Menu', 'name', name)
      const localVarPath = `/api/v1alpha1/menus/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Menu
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Menu: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menus`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {Menu} [menu] Updated menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Menu: async (name: string, menu?: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Menu', 'name', name)
      const localVarPath = `/api/v1alpha1/menus/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1MenuApi - functional programming interface
 * @export
 */
export const V1alpha1MenuApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1MenuApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Menu
     * @param {Menu} [menu] Fresh menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Menu(
      menu?: Menu,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Menu(menu, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Menu(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Menu(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Menu(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Menu(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Menu
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Menu(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Menu(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {Menu} [menu] Updated menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Menu(
      name: string,
      menu?: Menu,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Menu(name, menu, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1MenuApi - factory interface
 * @export
 */
export const V1alpha1MenuApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1MenuApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Menu
     * @param {Menu} [menu] Fresh menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Menu(menu?: Menu, options?: any): AxiosPromise<Menu> {
      return localVarFp.createv1alpha1Menu(menu, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Menu(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Menu(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Menu(name: string, options?: any): AxiosPromise<Menu> {
      return localVarFp.getv1alpha1Menu(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Menu
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Menu(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<MenuList> {
      return localVarFp
        .listv1alpha1Menu(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {Menu} [menu] Updated menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Menu(name: string, menu?: Menu, options?: any): AxiosPromise<Menu> {
      return localVarFp.updatev1alpha1Menu(name, menu, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1MenuApi - object-oriented interface
 * @export
 * @class V1alpha1MenuApi
 * @extends {BaseAPI}
 */
export class V1alpha1MenuApi extends BaseAPI {
  /**
   * Create v1alpha1/Menu
   * @param {Menu} [menu] Fresh menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public createv1alpha1Menu(menu?: Menu, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .createv1alpha1Menu(menu, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Menu
   * @param {string} name Name of menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public deletev1alpha1Menu(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .deletev1alpha1Menu(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Menu
   * @param {string} name Name of menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public getv1alpha1Menu(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .getv1alpha1Menu(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Menu
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public listv1alpha1Menu(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1MenuApiFp(this.configuration)
      .listv1alpha1Menu(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Menu
   * @param {string} name Name of menu
   * @param {Menu} [menu] Updated menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public updatev1alpha1Menu(name: string, menu?: Menu, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .updatev1alpha1Menu(name, menu, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1MenuItemApi - axios parameter creator
 * @export
 */
export const V1alpha1MenuItemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/MenuItem
     * @param {MenuItem} [menuItem] Fresh menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1MenuItem: async (menuItem?: MenuItem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menuitems`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menuItem, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1MenuItem: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1MenuItem', 'name', name)
      const localVarPath = `/api/v1alpha1/menuitems/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1MenuItem: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1MenuItem', 'name', name)
      const localVarPath = `/api/v1alpha1/menuitems/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/MenuItem
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1MenuItem: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menuitems`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {MenuItem} [menuItem] Updated menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1MenuItem: async (
      name: string,
      menuItem?: MenuItem,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1MenuItem', 'name', name)
      const localVarPath = `/api/v1alpha1/menuitems/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menuItem, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1MenuItemApi - functional programming interface
 * @export
 */
export const V1alpha1MenuItemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1MenuItemApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/MenuItem
     * @param {MenuItem} [menuItem] Fresh menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1MenuItem(
      menuItem?: MenuItem,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1MenuItem(menuItem, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1MenuItem(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1MenuItem(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1MenuItem(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1MenuItem(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/MenuItem
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1MenuItem(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItemList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1MenuItem(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {MenuItem} [menuItem] Updated menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1MenuItem(
      name: string,
      menuItem?: MenuItem,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1MenuItem(name, menuItem, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1MenuItemApi - factory interface
 * @export
 */
export const V1alpha1MenuItemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1MenuItemApiFp(configuration)
  return {
    /**
     * Create v1alpha1/MenuItem
     * @param {MenuItem} [menuItem] Fresh menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1MenuItem(menuItem?: MenuItem, options?: any): AxiosPromise<MenuItem> {
      return localVarFp.createv1alpha1MenuItem(menuItem, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1MenuItem(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1MenuItem(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1MenuItem(name: string, options?: any): AxiosPromise<MenuItem> {
      return localVarFp.getv1alpha1MenuItem(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/MenuItem
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1MenuItem(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<MenuItemList> {
      return localVarFp
        .listv1alpha1MenuItem(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {MenuItem} [menuItem] Updated menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1MenuItem(name: string, menuItem?: MenuItem, options?: any): AxiosPromise<MenuItem> {
      return localVarFp.updatev1alpha1MenuItem(name, menuItem, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1MenuItemApi - object-oriented interface
 * @export
 * @class V1alpha1MenuItemApi
 * @extends {BaseAPI}
 */
export class V1alpha1MenuItemApi extends BaseAPI {
  /**
   * Create v1alpha1/MenuItem
   * @param {MenuItem} [menuItem] Fresh menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public createv1alpha1MenuItem(menuItem?: MenuItem, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .createv1alpha1MenuItem(menuItem, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/MenuItem
   * @param {string} name Name of menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public deletev1alpha1MenuItem(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .deletev1alpha1MenuItem(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/MenuItem
   * @param {string} name Name of menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public getv1alpha1MenuItem(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .getv1alpha1MenuItem(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/MenuItem
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public listv1alpha1MenuItem(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .listv1alpha1MenuItem(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/MenuItem
   * @param {string} name Name of menuitem
   * @param {MenuItem} [menuItem] Updated menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public updatev1alpha1MenuItem(name: string, menuItem?: MenuItem, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .updatev1alpha1MenuItem(name, menuItem, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - axios parameter creator
 * @export
 */
export const V1alpha1PersonalAccessTokenApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken: async (
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken: async (
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - functional programming interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1PersonalAccessTokenApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1PersonalAccessToken(
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessTokenList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1PersonalAccessToken(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1PersonalAccessToken(
        name,
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - factory interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1PersonalAccessTokenApiFp(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .createv1alpha1PersonalAccessToken(personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<PersonalAccessToken> {
      return localVarFp.getv1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<PersonalAccessTokenList> {
      return localVarFp
        .listv1alpha1PersonalAccessToken(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - object-oriented interface
 * @export
 * @class V1alpha1PersonalAccessTokenApi
 * @extends {BaseAPI}
 */
export class V1alpha1PersonalAccessTokenApi extends BaseAPI {
  /**
   * Create v1alpha1/PersonalAccessToken
   * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public createv1alpha1PersonalAccessToken(personalAccessToken?: PersonalAccessToken, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .createv1alpha1PersonalAccessToken(personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public deletev1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .deletev1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public getv1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .getv1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/PersonalAccessToken
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public listv1alpha1PersonalAccessToken(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .listv1alpha1PersonalAccessToken(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public updatev1alpha1PersonalAccessToken(
    name: string,
    personalAccessToken?: PersonalAccessToken,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role: async (role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role: async (name: string, role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleApi - functional programming interface
 * @export
 */
export const V1alpha1RoleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Role(
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Role(role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Role(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Role(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Role(
      name: string,
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Role(name, role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleApi - factory interface
 * @export
 */
export const V1alpha1RoleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role(role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.createv1alpha1Role(role, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role(name: string, options?: any): AxiosPromise<Role> {
      return localVarFp.getv1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<RoleList> {
      return localVarFp
        .listv1alpha1Role(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role(name: string, role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.updatev1alpha1Role(name, role, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleApi - object-oriented interface
 * @export
 * @class V1alpha1RoleApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleApi extends BaseAPI {
  /**
   * Create v1alpha1/Role
   * @param {Role} [role] Fresh role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public createv1alpha1Role(role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .createv1alpha1Role(role, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public deletev1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .deletev1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public getv1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .getv1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Role
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public listv1alpha1Role(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1RoleApiFp(this.configuration)
      .listv1alpha1Role(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Role
   * @param {string} name Name of role
   * @param {Role} [role] Updated role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public updatev1alpha1Role(name: string, role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .updatev1alpha1Role(name, role, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleBindingApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleBindingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding: async (
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding: async (
      name: string,
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleBindingApi - functional programming interface
 * @export
 */
export const V1alpha1RoleBindingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleBindingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1RoleBinding(
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1RoleBinding(roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1RoleBinding(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBindingList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1RoleBinding(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1RoleBinding(
      name: string,
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1RoleBinding(name, roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleBindingApi - factory interface
 * @export
 */
export const V1alpha1RoleBindingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleBindingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.createv1alpha1RoleBinding(roleBinding, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding(name: string, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.getv1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<RoleBindingList> {
      return localVarFp
        .listv1alpha1RoleBinding(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp
        .updatev1alpha1RoleBinding(name, roleBinding, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleBindingApi - object-oriented interface
 * @export
 * @class V1alpha1RoleBindingApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleBindingApi extends BaseAPI {
  /**
   * Create v1alpha1/RoleBinding
   * @param {RoleBinding} [roleBinding] Fresh rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .createv1alpha1RoleBinding(roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public deletev1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .deletev1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public getv1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .getv1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/RoleBinding
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public listv1alpha1RoleBinding(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .listv1alpha1RoleBinding(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {RoleBinding} [roleBinding] Updated rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .updatev1alpha1RoleBinding(name, roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1SettingApi - axios parameter creator
 * @export
 */
export const V1alpha1SettingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting: async (setting?: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting: async (
      name: string,
      setting?: Setting,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1SettingApi - functional programming interface
 * @export
 */
export const V1alpha1SettingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1SettingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Setting(
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Setting(setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Setting(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Setting(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Setting(
      name: string,
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Setting(name, setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1SettingApi - factory interface
 * @export
 */
export const V1alpha1SettingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1SettingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting(setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.createv1alpha1Setting(setting, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting(name: string, options?: any): AxiosPromise<Setting> {
      return localVarFp.getv1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<SettingList> {
      return localVarFp
        .listv1alpha1Setting(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting(name: string, setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.updatev1alpha1Setting(name, setting, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1SettingApi - object-oriented interface
 * @export
 * @class V1alpha1SettingApi
 * @extends {BaseAPI}
 */
export class V1alpha1SettingApi extends BaseAPI {
  /**
   * Create v1alpha1/Setting
   * @param {Setting} [setting] Fresh setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public createv1alpha1Setting(setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .createv1alpha1Setting(setting, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public deletev1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .deletev1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public getv1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .getv1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Setting
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public listv1alpha1Setting(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1SettingApiFp(this.configuration)
      .listv1alpha1Setting(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {Setting} [setting] Updated setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public updatev1alpha1Setting(name: string, setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .updatev1alpha1Setting(name, setting, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1UserApi - axios parameter creator
 * @export
 */
export const V1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User: async (name: string, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1UserApi - functional programming interface
 * @export
 */
export const V1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1User(
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1User(user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1User(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1User(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1User(
      name: string,
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1User(name, user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1UserApi - factory interface
 * @export
 */
export const V1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1UserApiFp(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User(user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.createv1alpha1User(user, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User(name: string, options?: any): AxiosPromise<User> {
      return localVarFp.getv1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<UserList> {
      return localVarFp
        .listv1alpha1User(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User(name: string, user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.updatev1alpha1User(name, user, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1UserApi - object-oriented interface
 * @export
 * @class V1alpha1UserApi
 * @extends {BaseAPI}
 */
export class V1alpha1UserApi extends BaseAPI {
  /**
   * Create v1alpha1/User
   * @param {User} [user] Fresh user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public createv1alpha1User(user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .createv1alpha1User(user, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public deletev1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .deletev1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public getv1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .getv1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/User
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public listv1alpha1User(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1UserApiFp(this.configuration)
      .listv1alpha1User(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/User
   * @param {string} name Name of user
   * @param {User} [user] Updated user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public updatev1alpha1User(name: string, user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .updatev1alpha1User(name, user, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
