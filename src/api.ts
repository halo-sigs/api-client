/* tslint:disable */
/* eslint-disable */
/**
 * Halo Next API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface ConfigMap
 */
export interface ConfigMap {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ConfigMap
   */
  data?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ConfigMap
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface FileReverseProxyProvider
 */
export interface FileReverseProxyProvider {
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  directory?: string
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  filename?: string
}
/**
 *
 * @export
 * @interface GrantRequest
 */
export interface GrantRequest {
  /**
   *
   * @type {Set<string>}
   * @memberof GrantRequest
   */
  roles?: Set<string>
}
/**
 *
 * @export
 * @interface License
 */
export interface License {
  /**
   *
   * @type {string}
   * @memberof License
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof License
   */
  url?: string
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {LinkSpec}
   * @memberof Link
   */
  spec?: LinkSpec
  /**
   *
   * @type {string}
   * @memberof Link
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Link
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Link
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface LinkGroup
 */
export interface LinkGroup {
  /**
   *
   * @type {LinkGroupSpec}
   * @memberof LinkGroup
   */
  spec?: LinkGroupSpec
  /**
   *
   * @type {string}
   * @memberof LinkGroup
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof LinkGroup
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof LinkGroup
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface LinkGroupSpec
 */
export interface LinkGroupSpec {
  /**
   *
   * @type {string}
   * @memberof LinkGroupSpec
   */
  displayName: string
  /**
   *
   * @type {number}
   * @memberof LinkGroupSpec
   */
  priority?: number
}
/**
 *
 * @export
 * @interface LinkSpec
 */
export interface LinkSpec {
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  url: string
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  logo?: string
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof LinkSpec
   */
  groupName?: string
  /**
   *
   * @type {number}
   * @memberof LinkSpec
   */
  priority?: number
}
/**
 *
 * @export
 * @interface LoginHistory
 */
export interface LoginHistory {
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  loginAt: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  sourceIp: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  userAgent: string
  /**
   *
   * @type {boolean}
   * @memberof LoginHistory
   */
  successful: boolean
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  reason?: string
}
/**
 *
 * @export
 * @interface Metadata
 */
export interface Metadata {
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  name: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  labels?: { [key: string]: string } | null
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  annotations?: { [key: string]: string } | null
  /**
   *
   * @type {number}
   * @memberof Metadata
   */
  version?: number | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  creationTimestamp?: string | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  deletionTimestamp?: string | null
}
/**
 *
 * @export
 * @interface PersonalAccessToken
 */
export interface PersonalAccessToken {
  /**
   *
   * @type {PersonalAccessTokenSpec}
   * @memberof PersonalAccessToken
   */
  spec?: PersonalAccessTokenSpec
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof PersonalAccessToken
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PersonalAccessTokenSpec
 */
export interface PersonalAccessTokenSpec {
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  userName?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  displayName?: string
  /**
   *
   * @type {boolean}
   * @memberof PersonalAccessTokenSpec
   */
  revoked?: boolean
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  expiresAt?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  scopes?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  tokenDigest?: string
}
/**
 *
 * @export
 * @interface Plugin
 */
export interface Plugin {
  /**
   *
   * @type {PluginSpec}
   * @memberof Plugin
   */
  spec: PluginSpec
  /**
   *
   * @type {PluginStatus}
   * @memberof Plugin
   */
  status?: PluginStatus
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Plugin
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PluginSpec
 */
export interface PluginSpec {
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  displayName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  version?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  author?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  logo?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PluginSpec
   */
  pluginDependencies?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  homepage?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  description?: string
  /**
   *
   * @type {Array<License>}
   * @memberof PluginSpec
   */
  license?: Array<License>
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  requires?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  pluginClass?: string
  /**
   *
   * @type {boolean}
   * @memberof PluginSpec
   */
  enabled?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof PluginSpec
   */
  extensionLocations?: Array<string>
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  settingName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  configMapName?: string
}
/**
 *
 * @export
 * @interface PluginStatus
 */
export interface PluginStatus {
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  phase?: PluginStatusPhaseEnum
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  reason?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastStartTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastTransitionTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  entry?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  stylesheet?: string
}

export const PluginStatusPhaseEnum = {
  Created: 'CREATED',
  Disabled: 'DISABLED',
  Resolved: 'RESOLVED',
  Started: 'STARTED',
  Stopped: 'STOPPED',
  Failed: 'FAILED',
} as const

export type PluginStatusPhaseEnum = typeof PluginStatusPhaseEnum[keyof typeof PluginStatusPhaseEnum]

/**
 *
 * @export
 * @interface PolicyRule
 */
export interface PolicyRule {
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  apiGroups?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resources?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resourceNames?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  nonResourceURLs?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  verbs?: Array<string>
}
/**
 *
 * @export
 * @interface Post
 */
export interface Post {
  /**
   *
   * @type {PostSpec}
   * @memberof Post
   */
  spec?: PostSpec
  /**
   *
   * @type {string}
   * @memberof Post
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Post
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Post
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PostSpec
 */
export interface PostSpec {
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  content?: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  keyword?: string
}
/**
 *
 * @export
 * @interface ReverseProxy
 */
export interface ReverseProxy {
  /**
   *
   * @type {Array<ReverseProxyRule>}
   * @memberof ReverseProxy
   */
  rules?: Array<ReverseProxyRule>
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ReverseProxy
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ReverseProxyRule
 */
export interface ReverseProxyRule {
  /**
   *
   * @type {string}
   * @memberof ReverseProxyRule
   */
  path?: string
  /**
   *
   * @type {FileReverseProxyProvider}
   * @memberof ReverseProxyRule
   */
  file?: FileReverseProxyProvider
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {Array<PolicyRule>}
   * @memberof Role
   */
  rules: Array<PolicyRule>
  /**
   *
   * @type {string}
   * @memberof Role
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Role
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Role
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleBinding
 */
export interface RoleBinding {
  /**
   *
   * @type {Array<Subject>}
   * @memberof RoleBinding
   */
  subjects?: Array<Subject>
  /**
   *
   * @type {RoleRef}
   * @memberof RoleBinding
   */
  roleRef?: RoleRef
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof RoleBinding
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleRef
 */
export interface RoleRef {
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
  /**
   *
   * @type {Array<SettingSpec>}
   * @memberof Setting
   */
  spec: Array<SettingSpec>
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Setting
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface SettingSpec
 */
export interface SettingSpec {
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  group: string
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  label?: string
  /**
   *
   * @type {Array<object>}
   * @memberof SettingSpec
   */
  formSchema?: Array<object>
}
/**
 *
 * @export
 * @interface Subject
 */
export interface Subject {
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {UserSpec}
   * @memberof User
   */
  spec: UserSpec
  /**
   *
   * @type {UserStatus}
   * @memberof User
   */
  status?: UserStatus
  /**
   *
   * @type {string}
   * @memberof User
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof User
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface UserSpec
 */
export interface UserSpec {
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  avatar?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  bio?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  registeredAt?: string
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  twoFactorAuthEnabled?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  disabled?: boolean
  /**
   *
   * @type {number}
   * @memberof UserSpec
   */
  loginHistoryLimit?: number
}
/**
 *
 * @export
 * @interface UserStatus
 */
export interface UserStatus {
  /**
   *
   * @type {string}
   * @memberof UserStatus
   */
  lastLoginAt?: string
  /**
   *
   * @type {Array<LoginHistory>}
   * @memberof UserStatus
   */
  loginHistories?: Array<LoginHistory>
}

/**
 * ApiHaloRunV1alpha1UserApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/-`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getPermissions', 'name', name)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission: async (
      name: string,
      grantRequest: GrantRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('grantPermission', 'name', name)
      // verify required parameter 'grantRequest' is not null or undefined
      assertParamExists('grantPermission', 'grantRequest', grantRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(grantRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUserDetail(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserDetail(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPermissions(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissions(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grantPermission(
      name: string,
      grantRequest: GrantRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grantPermission(name, grantRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1UserApiFp(configuration)
  return {
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail(options?: any): AxiosPromise<User> {
      return localVarFp.getCurrentUserDetail(options).then((request) => request(axios, basePath))
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions(name: string, options?: any): AxiosPromise<string> {
      return localVarFp.getPermissions(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission(name: string, grantRequest: GrantRequest, options?: any): AxiosPromise<User> {
      return localVarFp.grantPermission(name, grantRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1UserApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1UserApi extends BaseAPI {
  /**
   * Get current user detail
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getCurrentUserDetail(options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getCurrentUserDetail(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get permissions of user
   * @param {string} name User name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getPermissions(name: string, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getPermissions(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Grant permissions to user
   * @param {string} name User name
   * @param {GrantRequest} grantRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public grantPermission(name: string, grantRequest: GrantRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .grantPermission(name, grantRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - axios parameter creator
 * @export
 */
export const CoreHaloRunV1alpha1LinkApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create core.halo.run/v1alpha1/Link
     * @param {Link} [link] Fresh link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1Link: async (link?: Link, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/links`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(link, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1Link: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecoreHaloRunV1alpha1Link', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/links/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1Link: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcoreHaloRunV1alpha1Link', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/links/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List core.halo.run/v1alpha1/Link
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1Link: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/links`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {Link} [link] Updated link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1Link: async (
      name: string,
      link?: Link,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecoreHaloRunV1alpha1Link', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/links/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(link, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - functional programming interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CoreHaloRunV1alpha1LinkApiAxiosParamCreator(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/Link
     * @param {Link} [link] Fresh link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcoreHaloRunV1alpha1Link(
      link?: Link,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcoreHaloRunV1alpha1Link(link, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecoreHaloRunV1alpha1Link(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecoreHaloRunV1alpha1Link(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcoreHaloRunV1alpha1Link(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcoreHaloRunV1alpha1Link(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List core.halo.run/v1alpha1/Link
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcoreHaloRunV1alpha1Link(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Link>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcoreHaloRunV1alpha1Link(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {Link} [link] Updated link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecoreHaloRunV1alpha1Link(
      name: string,
      link?: Link,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Link>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecoreHaloRunV1alpha1Link(name, link, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - factory interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CoreHaloRunV1alpha1LinkApiFp(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/Link
     * @param {Link} [link] Fresh link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1Link(link?: Link, options?: any): AxiosPromise<Link> {
      return localVarFp.createcoreHaloRunV1alpha1Link(link, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1Link(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecoreHaloRunV1alpha1Link(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1Link(name: string, options?: any): AxiosPromise<Link> {
      return localVarFp.getcoreHaloRunV1alpha1Link(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List core.halo.run/v1alpha1/Link
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1Link(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<Array<Link>> {
      return localVarFp
        .listcoreHaloRunV1alpha1Link(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update core.halo.run/v1alpha1/Link
     * @param {string} name Name of link
     * @param {Link} [link] Updated link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1Link(name: string, link?: Link, options?: any): AxiosPromise<Link> {
      return localVarFp.updatecoreHaloRunV1alpha1Link(name, link, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkApi - object-oriented interface
 * @export
 * @class CoreHaloRunV1alpha1LinkApi
 * @extends {BaseAPI}
 */
export class CoreHaloRunV1alpha1LinkApi extends BaseAPI {
  /**
   * Create core.halo.run/v1alpha1/Link
   * @param {Link} [link] Fresh link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public createcoreHaloRunV1alpha1Link(link?: Link, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .createcoreHaloRunV1alpha1Link(link, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete core.halo.run/v1alpha1/Link
   * @param {string} name Name of link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public deletecoreHaloRunV1alpha1Link(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .deletecoreHaloRunV1alpha1Link(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get core.halo.run/v1alpha1/Link
   * @param {string} name Name of link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public getcoreHaloRunV1alpha1Link(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .getcoreHaloRunV1alpha1Link(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List core.halo.run/v1alpha1/Link
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public listcoreHaloRunV1alpha1Link(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .listcoreHaloRunV1alpha1Link(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update core.halo.run/v1alpha1/Link
   * @param {string} name Name of link
   * @param {Link} [link] Updated link
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkApi
   */
  public updatecoreHaloRunV1alpha1Link(name: string, link?: Link, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkApiFp(this.configuration)
      .updatecoreHaloRunV1alpha1Link(name, link, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - axios parameter creator
 * @export
 */
export const CoreHaloRunV1alpha1LinkGroupApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create core.halo.run/v1alpha1/LinkGroup
     * @param {LinkGroup} [linkGroup] Fresh linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1LinkGroup: async (
      linkGroup?: LinkGroup,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(linkGroup, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1LinkGroup: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecoreHaloRunV1alpha1LinkGroup', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1LinkGroup: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcoreHaloRunV1alpha1LinkGroup', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List core.halo.run/v1alpha1/LinkGroup
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1LinkGroup: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {LinkGroup} [linkGroup] Updated linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1LinkGroup: async (
      name: string,
      linkGroup?: LinkGroup,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecoreHaloRunV1alpha1LinkGroup', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/linkgroups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(linkGroup, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - functional programming interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkGroupApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CoreHaloRunV1alpha1LinkGroupApiAxiosParamCreator(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/LinkGroup
     * @param {LinkGroup} [linkGroup] Fresh linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcoreHaloRunV1alpha1LinkGroup(
      linkGroup?: LinkGroup,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkGroup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcoreHaloRunV1alpha1LinkGroup(linkGroup, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecoreHaloRunV1alpha1LinkGroup(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecoreHaloRunV1alpha1LinkGroup(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcoreHaloRunV1alpha1LinkGroup(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkGroup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcoreHaloRunV1alpha1LinkGroup(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List core.halo.run/v1alpha1/LinkGroup
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcoreHaloRunV1alpha1LinkGroup(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LinkGroup>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcoreHaloRunV1alpha1LinkGroup(
        page,
        size,
        sort,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {LinkGroup} [linkGroup] Updated linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecoreHaloRunV1alpha1LinkGroup(
      name: string,
      linkGroup?: LinkGroup,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkGroup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecoreHaloRunV1alpha1LinkGroup(
        name,
        linkGroup,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - factory interface
 * @export
 */
export const CoreHaloRunV1alpha1LinkGroupApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CoreHaloRunV1alpha1LinkGroupApiFp(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/LinkGroup
     * @param {LinkGroup} [linkGroup] Fresh linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1LinkGroup(linkGroup?: LinkGroup, options?: any): AxiosPromise<LinkGroup> {
      return localVarFp
        .createcoreHaloRunV1alpha1LinkGroup(linkGroup, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1LinkGroup(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecoreHaloRunV1alpha1LinkGroup(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1LinkGroup(name: string, options?: any): AxiosPromise<LinkGroup> {
      return localVarFp.getcoreHaloRunV1alpha1LinkGroup(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List core.halo.run/v1alpha1/LinkGroup
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1LinkGroup(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<Array<LinkGroup>> {
      return localVarFp
        .listcoreHaloRunV1alpha1LinkGroup(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update core.halo.run/v1alpha1/LinkGroup
     * @param {string} name Name of linkgroup
     * @param {LinkGroup} [linkGroup] Updated linkgroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1LinkGroup(name: string, linkGroup?: LinkGroup, options?: any): AxiosPromise<LinkGroup> {
      return localVarFp
        .updatecoreHaloRunV1alpha1LinkGroup(name, linkGroup, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CoreHaloRunV1alpha1LinkGroupApi - object-oriented interface
 * @export
 * @class CoreHaloRunV1alpha1LinkGroupApi
 * @extends {BaseAPI}
 */
export class CoreHaloRunV1alpha1LinkGroupApi extends BaseAPI {
  /**
   * Create core.halo.run/v1alpha1/LinkGroup
   * @param {LinkGroup} [linkGroup] Fresh linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public createcoreHaloRunV1alpha1LinkGroup(linkGroup?: LinkGroup, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .createcoreHaloRunV1alpha1LinkGroup(linkGroup, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete core.halo.run/v1alpha1/LinkGroup
   * @param {string} name Name of linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public deletecoreHaloRunV1alpha1LinkGroup(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .deletecoreHaloRunV1alpha1LinkGroup(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get core.halo.run/v1alpha1/LinkGroup
   * @param {string} name Name of linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public getcoreHaloRunV1alpha1LinkGroup(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .getcoreHaloRunV1alpha1LinkGroup(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List core.halo.run/v1alpha1/LinkGroup
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public listcoreHaloRunV1alpha1LinkGroup(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .listcoreHaloRunV1alpha1LinkGroup(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update core.halo.run/v1alpha1/LinkGroup
   * @param {string} name Name of linkgroup
   * @param {LinkGroup} [linkGroup] Updated linkgroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1LinkGroupApi
   */
  public updatecoreHaloRunV1alpha1LinkGroup(name: string, linkGroup?: LinkGroup, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1LinkGroupApiFp(this.configuration)
      .updatecoreHaloRunV1alpha1LinkGroup(name, linkGroup, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CoreHaloRunV1alpha1PostApi - axios parameter creator
 * @export
 */
export const CoreHaloRunV1alpha1PostApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create core.halo.run/v1alpha1/Post
     * @param {Post} [post] Fresh post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1Post: async (post?: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1Post: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecoreHaloRunV1alpha1Post', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/posts/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1Post: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcoreHaloRunV1alpha1Post', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/posts/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List core.halo.run/v1alpha1/Post
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1Post: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/core.halo.run/v1alpha1/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {Post} [post] Updated post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1Post: async (
      name: string,
      post?: Post,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecoreHaloRunV1alpha1Post', 'name', name)
      const localVarPath = `/apis/core.halo.run/v1alpha1/posts/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CoreHaloRunV1alpha1PostApi - functional programming interface
 * @export
 */
export const CoreHaloRunV1alpha1PostApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CoreHaloRunV1alpha1PostApiAxiosParamCreator(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/Post
     * @param {Post} [post] Fresh post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcoreHaloRunV1alpha1Post(
      post?: Post,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcoreHaloRunV1alpha1Post(post, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecoreHaloRunV1alpha1Post(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecoreHaloRunV1alpha1Post(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcoreHaloRunV1alpha1Post(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcoreHaloRunV1alpha1Post(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List core.halo.run/v1alpha1/Post
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcoreHaloRunV1alpha1Post(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Post>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcoreHaloRunV1alpha1Post(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {Post} [post] Updated post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecoreHaloRunV1alpha1Post(
      name: string,
      post?: Post,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecoreHaloRunV1alpha1Post(name, post, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * CoreHaloRunV1alpha1PostApi - factory interface
 * @export
 */
export const CoreHaloRunV1alpha1PostApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CoreHaloRunV1alpha1PostApiFp(configuration)
  return {
    /**
     * Create core.halo.run/v1alpha1/Post
     * @param {Post} [post] Fresh post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcoreHaloRunV1alpha1Post(post?: Post, options?: any): AxiosPromise<Post> {
      return localVarFp.createcoreHaloRunV1alpha1Post(post, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecoreHaloRunV1alpha1Post(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecoreHaloRunV1alpha1Post(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcoreHaloRunV1alpha1Post(name: string, options?: any): AxiosPromise<Post> {
      return localVarFp.getcoreHaloRunV1alpha1Post(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List core.halo.run/v1alpha1/Post
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcoreHaloRunV1alpha1Post(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<Array<Post>> {
      return localVarFp
        .listcoreHaloRunV1alpha1Post(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update core.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {Post} [post] Updated post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecoreHaloRunV1alpha1Post(name: string, post?: Post, options?: any): AxiosPromise<Post> {
      return localVarFp.updatecoreHaloRunV1alpha1Post(name, post, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * CoreHaloRunV1alpha1PostApi - object-oriented interface
 * @export
 * @class CoreHaloRunV1alpha1PostApi
 * @extends {BaseAPI}
 */
export class CoreHaloRunV1alpha1PostApi extends BaseAPI {
  /**
   * Create core.halo.run/v1alpha1/Post
   * @param {Post} [post] Fresh post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1PostApi
   */
  public createcoreHaloRunV1alpha1Post(post?: Post, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1PostApiFp(this.configuration)
      .createcoreHaloRunV1alpha1Post(post, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete core.halo.run/v1alpha1/Post
   * @param {string} name Name of post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1PostApi
   */
  public deletecoreHaloRunV1alpha1Post(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1PostApiFp(this.configuration)
      .deletecoreHaloRunV1alpha1Post(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get core.halo.run/v1alpha1/Post
   * @param {string} name Name of post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1PostApi
   */
  public getcoreHaloRunV1alpha1Post(name: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1PostApiFp(this.configuration)
      .getcoreHaloRunV1alpha1Post(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List core.halo.run/v1alpha1/Post
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1PostApi
   */
  public listcoreHaloRunV1alpha1Post(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1PostApiFp(this.configuration)
      .listcoreHaloRunV1alpha1Post(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update core.halo.run/v1alpha1/Post
   * @param {string} name Name of post
   * @param {Post} [post] Updated post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoreHaloRunV1alpha1PostApi
   */
  public updatecoreHaloRunV1alpha1Post(name: string, post?: Post, options?: AxiosRequestConfig) {
    return CoreHaloRunV1alpha1PostApiFp(this.configuration)
      .updatecoreHaloRunV1alpha1Post(name, post, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin: async (
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin: async (
      name: string,
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1PluginApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1Plugin(
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1Plugin(plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plugin>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1Plugin(
        page,
        size,
        sort,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1Plugin(
      name: string,
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1PluginApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp.createpluginHaloRunV1alpha1Plugin(plugin, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletepluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<Plugin> {
      return localVarFp.getpluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<Array<Plugin>> {
      return localVarFp
        .listpluginHaloRunV1alpha1Plugin(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp
        .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1PluginApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1PluginApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/Plugin
   * @param {Plugin} [plugin] Fresh plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .createpluginHaloRunV1alpha1Plugin(plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public deletepluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public getpluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .getpluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/Plugin
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public listpluginHaloRunV1alpha1Plugin(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .listpluginHaloRunV1alpha1Plugin(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {Plugin} [plugin] Updated plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy: async (
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1ReverseProxy(
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1ReverseProxy(
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReverseProxy>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1ReverseProxy(
        page,
        size,
        sort,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1ReverseProxy(
        name,
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1ReverseProxyApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp
        .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp.getpluginHaloRunV1alpha1ReverseProxy(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<Array<ReverseProxy>> {
      return localVarFp
        .listpluginHaloRunV1alpha1ReverseProxy(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: any,
    ): AxiosPromise<ReverseProxy> {
      return localVarFp
        .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1ReverseProxyApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1ReverseProxyApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/ReverseProxy
   * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .getpluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/ReverseProxy
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public listpluginHaloRunV1alpha1ReverseProxy(
    page?: number,
    size?: number,
    sort?: string,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .listpluginHaloRunV1alpha1ReverseProxy(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public updatepluginHaloRunV1alpha1ReverseProxy(
    name: string,
    reverseProxy?: ReverseProxy,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1ConfigMapApi - axios parameter creator
 * @export
 */
export const V1alpha1ConfigMapApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap: async (configMap?: ConfigMap, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap: async (
      name: string,
      configMap?: ConfigMap,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1ConfigMapApi - functional programming interface
 * @export
 */
export const V1alpha1ConfigMapApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1ConfigMapApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1ConfigMap(
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1ConfigMap(configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1ConfigMap(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigMap>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1ConfigMap(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1ConfigMap(
      name: string,
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1ConfigMap(name, configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1ConfigMapApi - factory interface
 * @export
 */
export const V1alpha1ConfigMapApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1ConfigMapApiFp(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap(configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.createv1alpha1ConfigMap(configMap, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap(name: string, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.getv1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<Array<ConfigMap>> {
      return localVarFp.listv1alpha1ConfigMap(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.updatev1alpha1ConfigMap(name, configMap, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1ConfigMapApi - object-oriented interface
 * @export
 * @class V1alpha1ConfigMapApi
 * @extends {BaseAPI}
 */
export class V1alpha1ConfigMapApi extends BaseAPI {
  /**
   * Create v1alpha1/ConfigMap
   * @param {ConfigMap} [configMap] Fresh configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public createv1alpha1ConfigMap(configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .createv1alpha1ConfigMap(configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public deletev1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .deletev1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public getv1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .getv1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/ConfigMap
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public listv1alpha1ConfigMap(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .listv1alpha1ConfigMap(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {ConfigMap} [configMap] Updated configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .updatev1alpha1ConfigMap(name, configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - axios parameter creator
 * @export
 */
export const V1alpha1PersonalAccessTokenApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken: async (
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken: async (
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - functional programming interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1PersonalAccessTokenApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1PersonalAccessToken(
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonalAccessToken>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1PersonalAccessToken(
        page,
        size,
        sort,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1PersonalAccessToken(
        name,
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - factory interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1PersonalAccessTokenApiFp(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .createv1alpha1PersonalAccessToken(personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<PersonalAccessToken> {
      return localVarFp.getv1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<Array<PersonalAccessToken>> {
      return localVarFp
        .listv1alpha1PersonalAccessToken(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - object-oriented interface
 * @export
 * @class V1alpha1PersonalAccessTokenApi
 * @extends {BaseAPI}
 */
export class V1alpha1PersonalAccessTokenApi extends BaseAPI {
  /**
   * Create v1alpha1/PersonalAccessToken
   * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public createv1alpha1PersonalAccessToken(personalAccessToken?: PersonalAccessToken, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .createv1alpha1PersonalAccessToken(personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public deletev1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .deletev1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public getv1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .getv1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/PersonalAccessToken
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public listv1alpha1PersonalAccessToken(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .listv1alpha1PersonalAccessToken(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public updatev1alpha1PersonalAccessToken(
    name: string,
    personalAccessToken?: PersonalAccessToken,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role: async (role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role: async (name: string, role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleApi - functional programming interface
 * @export
 */
export const V1alpha1RoleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Role(
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Role(role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Role(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Role(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Role(
      name: string,
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Role(name, role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleApi - factory interface
 * @export
 */
export const V1alpha1RoleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role(role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.createv1alpha1Role(role, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role(name: string, options?: any): AxiosPromise<Role> {
      return localVarFp.getv1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<Array<Role>> {
      return localVarFp.listv1alpha1Role(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role(name: string, role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.updatev1alpha1Role(name, role, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleApi - object-oriented interface
 * @export
 * @class V1alpha1RoleApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleApi extends BaseAPI {
  /**
   * Create v1alpha1/Role
   * @param {Role} [role] Fresh role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public createv1alpha1Role(role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .createv1alpha1Role(role, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public deletev1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .deletev1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public getv1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .getv1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Role
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public listv1alpha1Role(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .listv1alpha1Role(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Role
   * @param {string} name Name of role
   * @param {Role} [role] Updated role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public updatev1alpha1Role(name: string, role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .updatev1alpha1Role(name, role, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleBindingApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleBindingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding: async (
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding: async (
      name: string,
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleBindingApi - functional programming interface
 * @export
 */
export const V1alpha1RoleBindingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleBindingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1RoleBinding(
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1RoleBinding(roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1RoleBinding(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleBinding>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1RoleBinding(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1RoleBinding(
      name: string,
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1RoleBinding(name, roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleBindingApi - factory interface
 * @export
 */
export const V1alpha1RoleBindingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleBindingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.createv1alpha1RoleBinding(roleBinding, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding(name: string, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.getv1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<Array<RoleBinding>> {
      return localVarFp.listv1alpha1RoleBinding(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp
        .updatev1alpha1RoleBinding(name, roleBinding, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleBindingApi - object-oriented interface
 * @export
 * @class V1alpha1RoleBindingApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleBindingApi extends BaseAPI {
  /**
   * Create v1alpha1/RoleBinding
   * @param {RoleBinding} [roleBinding] Fresh rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .createv1alpha1RoleBinding(roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public deletev1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .deletev1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public getv1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .getv1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/RoleBinding
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public listv1alpha1RoleBinding(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .listv1alpha1RoleBinding(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {RoleBinding} [roleBinding] Updated rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .updatev1alpha1RoleBinding(name, roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1SettingApi - axios parameter creator
 * @export
 */
export const V1alpha1SettingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting: async (setting?: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting: async (
      name: string,
      setting?: Setting,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1SettingApi - functional programming interface
 * @export
 */
export const V1alpha1SettingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1SettingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Setting(
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Setting(setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Setting(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Setting>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Setting(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Setting(
      name: string,
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Setting(name, setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1SettingApi - factory interface
 * @export
 */
export const V1alpha1SettingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1SettingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting(setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.createv1alpha1Setting(setting, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting(name: string, options?: any): AxiosPromise<Setting> {
      return localVarFp.getv1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<Array<Setting>> {
      return localVarFp.listv1alpha1Setting(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting(name: string, setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.updatev1alpha1Setting(name, setting, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1SettingApi - object-oriented interface
 * @export
 * @class V1alpha1SettingApi
 * @extends {BaseAPI}
 */
export class V1alpha1SettingApi extends BaseAPI {
  /**
   * Create v1alpha1/Setting
   * @param {Setting} [setting] Fresh setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public createv1alpha1Setting(setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .createv1alpha1Setting(setting, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public deletev1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .deletev1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public getv1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .getv1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Setting
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public listv1alpha1Setting(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .listv1alpha1Setting(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {Setting} [setting] Updated setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public updatev1alpha1Setting(name: string, setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .updatev1alpha1Setting(name, setting, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1UserApi - axios parameter creator
 * @export
 */
export const V1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User: async (name: string, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1UserApi - functional programming interface
 * @export
 */
export const V1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1User(
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1User(user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1User(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1User(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1User(
      name: string,
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1User(name, user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1UserApi - factory interface
 * @export
 */
export const V1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1UserApiFp(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User(user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.createv1alpha1User(user, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User(name: string, options?: any): AxiosPromise<User> {
      return localVarFp.getv1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<Array<User>> {
      return localVarFp.listv1alpha1User(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User(name: string, user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.updatev1alpha1User(name, user, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1UserApi - object-oriented interface
 * @export
 * @class V1alpha1UserApi
 * @extends {BaseAPI}
 */
export class V1alpha1UserApi extends BaseAPI {
  /**
   * Create v1alpha1/User
   * @param {User} [user] Fresh user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public createv1alpha1User(user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .createv1alpha1User(user, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public deletev1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .deletev1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public getv1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .getv1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/User
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public listv1alpha1User(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .listv1alpha1User(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/User
   * @param {string} name Name of user
   * @param {User} [user] Updated user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public updatev1alpha1User(name: string, user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .updatev1alpha1User(name, user, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
