/* tslint:disable */
/* eslint-disable */
/**
 * Halo Next API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
  /**
   * New password.
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface ConfigMap
 */
export interface ConfigMap {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ConfigMap
   */
  data?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ConfigMap
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ConfigMapList
 */
export interface ConfigMapList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ConfigMapList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ConfigMapList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ConfigMapList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<ConfigMap>}
   * @memberof ConfigMapList
   */
  items: Array<ConfigMap>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface FileReverseProxyProvider
 */
export interface FileReverseProxyProvider {
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  directory?: string
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  filename?: string
}
/**
 *
 * @export
 * @interface GrantRequest
 */
export interface GrantRequest {
  /**
   *
   * @type {Set<string>}
   * @memberof GrantRequest
   */
  roles?: Set<string>
}
/**
 *
 * @export
 * @interface License
 */
export interface License {
  /**
   *
   * @type {string}
   * @memberof License
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof License
   */
  url?: string
}
/**
 *
 * @export
 * @interface Link
 */
export interface Link {
  /**
   *
   * @type {string}
   * @memberof Link
   */
  href?: string
  /**
   *
   * @type {boolean}
   * @memberof Link
   */
  templated?: boolean
}
/**
 *
 * @export
 * @interface LoginHistory
 */
export interface LoginHistory {
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  loginAt: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  sourceIp: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  userAgent: string
  /**
   *
   * @type {boolean}
   * @memberof LoginHistory
   */
  successful: boolean
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  reason?: string
}
/**
 *
 * @export
 * @interface Metadata
 */
export interface Metadata {
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  name: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  labels?: { [key: string]: string } | null
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  annotations?: { [key: string]: string } | null
  /**
   *
   * @type {number}
   * @memberof Metadata
   */
  version?: number | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  creationTimestamp?: string | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  deletionTimestamp?: string | null
}
/**
 *
 * @export
 * @interface PersonalAccessToken
 */
export interface PersonalAccessToken {
  /**
   *
   * @type {PersonalAccessTokenSpec}
   * @memberof PersonalAccessToken
   */
  spec?: PersonalAccessTokenSpec
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof PersonalAccessToken
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PersonalAccessTokenList
 */
export interface PersonalAccessTokenList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<PersonalAccessToken>}
   * @memberof PersonalAccessTokenList
   */
  items: Array<PersonalAccessToken>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PersonalAccessTokenSpec
 */
export interface PersonalAccessTokenSpec {
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  userName?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  displayName?: string
  /**
   *
   * @type {boolean}
   * @memberof PersonalAccessTokenSpec
   */
  revoked?: boolean
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  expiresAt?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  scopes?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  tokenDigest?: string
}
/**
 *
 * @export
 * @interface Plugin
 */
export interface Plugin {
  /**
   *
   * @type {PluginSpec}
   * @memberof Plugin
   */
  spec: PluginSpec
  /**
   *
   * @type {PluginStatus}
   * @memberof Plugin
   */
  status?: PluginStatus
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Plugin
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PluginList
 */
export interface PluginList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PluginList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PluginList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PluginList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Plugin>}
   * @memberof PluginList
   */
  items: Array<Plugin>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PluginList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PluginList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PluginList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PluginList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PluginSpec
 */
export interface PluginSpec {
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  displayName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  version?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  author?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  logo?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PluginSpec
   */
  pluginDependencies?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  homepage?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  description?: string
  /**
   *
   * @type {Array<License>}
   * @memberof PluginSpec
   */
  license?: Array<License>
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  requires?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   * @deprecated
   */
  pluginClass?: string
  /**
   *
   * @type {boolean}
   * @memberof PluginSpec
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  settingName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  configMapName?: string
}
/**
 *
 * @export
 * @interface PluginStatus
 */
export interface PluginStatus {
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  phase?: PluginStatusPhaseEnum
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  reason?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastStartTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastTransitionTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  entry?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  stylesheet?: string
}

export const PluginStatusPhaseEnum = {
  Created: 'CREATED',
  Disabled: 'DISABLED',
  Resolved: 'RESOLVED',
  Started: 'STARTED',
  Stopped: 'STOPPED',
  Failed: 'FAILED',
} as const

export type PluginStatusPhaseEnum = typeof PluginStatusPhaseEnum[keyof typeof PluginStatusPhaseEnum]

/**
 *
 * @export
 * @interface PolicyRule
 */
export interface PolicyRule {
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  apiGroups?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resources?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resourceNames?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  nonResourceURLs?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  verbs?: Array<string>
}
/**
 *
 * @export
 * @interface ReverseProxy
 */
export interface ReverseProxy {
  /**
   *
   * @type {Array<ReverseProxyRule>}
   * @memberof ReverseProxy
   */
  rules?: Array<ReverseProxyRule>
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ReverseProxy
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ReverseProxyList
 */
export interface ReverseProxyList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReverseProxyList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReverseProxyList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ReverseProxyList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<ReverseProxy>}
   * @memberof ReverseProxyList
   */
  items: Array<ReverseProxy>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface ReverseProxyRule
 */
export interface ReverseProxyRule {
  /**
   *
   * @type {string}
   * @memberof ReverseProxyRule
   */
  path?: string
  /**
   *
   * @type {FileReverseProxyProvider}
   * @memberof ReverseProxyRule
   */
  file?: FileReverseProxyProvider
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {Array<PolicyRule>}
   * @memberof Role
   */
  rules: Array<PolicyRule>
  /**
   *
   * @type {string}
   * @memberof Role
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Role
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Role
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleBinding
 */
export interface RoleBinding {
  /**
   *
   * @type {Array<Subject>}
   * @memberof RoleBinding
   */
  subjects?: Array<Subject>
  /**
   *
   * @type {RoleRef}
   * @memberof RoleBinding
   */
  roleRef?: RoleRef
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof RoleBinding
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleBindingList
 */
export interface RoleBindingList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleBindingList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleBindingList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof RoleBindingList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<RoleBinding>}
   * @memberof RoleBindingList
   */
  items: Array<RoleBinding>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface RoleList
 */
export interface RoleList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof RoleList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Role>}
   * @memberof RoleList
   */
  items: Array<Role>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof RoleList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof RoleList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface RoleRef
 */
export interface RoleRef {
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
  /**
   *
   * @type {Array<SettingSpec>}
   * @memberof Setting
   */
  spec: Array<SettingSpec>
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Setting
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface SettingList
 */
export interface SettingList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SettingList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SettingList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof SettingList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Setting>}
   * @memberof SettingList
   */
  items: Array<Setting>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof SettingList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof SettingList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SettingList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SettingList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface SettingSpec
 */
export interface SettingSpec {
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  group: string
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  label?: string
  /**
   *
   * @type {Array<object>}
   * @memberof SettingSpec
   */
  formSchema?: Array<object>
}
/**
 *
 * @export
 * @interface Subject
 */
export interface Subject {
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {UserSpec}
   * @memberof User
   */
  spec: UserSpec
  /**
   *
   * @type {UserStatus}
   * @memberof User
   */
  status?: UserStatus
  /**
   *
   * @type {string}
   * @memberof User
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof User
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof UserList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof UserList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof UserList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<User>}
   * @memberof UserList
   */
  items: Array<User>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof UserList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof UserList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof UserList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof UserList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface UserPermission
 */
export interface UserPermission {
  /**
   *
   * @type {Set<Role>}
   * @memberof UserPermission
   */
  roles: Set<Role>
  /**
   *
   * @type {Set<string>}
   * @memberof UserPermission
   */
  uiPermissions: Set<string>
}
/**
 *
 * @export
 * @interface UserSpec
 */
export interface UserSpec {
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  avatar?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  bio?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  registeredAt?: string
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  twoFactorAuthEnabled?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  disabled?: boolean
  /**
   *
   * @type {number}
   * @memberof UserSpec
   */
  loginHistoryLimit?: number
}
/**
 *
 * @export
 * @interface UserStatus
 */
export interface UserStatus {
  /**
   *
   * @type {string}
   * @memberof UserStatus
   */
  lastLoginAt?: string
  /**
   *
   * @type {Array<LoginHistory>}
   * @memberof UserStatus
   */
  loginHistories?: Array<LoginHistory>
}

/**
 * ActuatorApi - axios parameter creator
 * @export
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/actuator/health`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Actuator web endpoint \'health-path\'
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthPath: async (path: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('healthPath', 'path', path)
      const localVarPath = `/actuator/health/{*path}`.replace(`{${'*path'}}`, encodeURIComponent(String(path)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    links: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/actuator`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ActuatorApi - functional programming interface
 * @export
 */
export const ActuatorApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async health(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.health(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Actuator web endpoint \'health-path\'
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthPath(
      path: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.healthPath(path, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async links(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: Link } }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.links(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ActuatorApi - factory interface
 * @export
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ActuatorApiFp(configuration)
  return {
    /**
     *
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health(options?: any): AxiosPromise<object> {
      return localVarFp.health(options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Actuator web endpoint \'health-path\'
     * @param {string} path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthPath(path: string, options?: any): AxiosPromise<object> {
      return localVarFp.healthPath(path, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    links(options?: any): AxiosPromise<{ [key: string]: { [key: string]: Link } }> {
      return localVarFp.links(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ActuatorApi - object-oriented interface
 * @export
 * @class ActuatorApi
 * @extends {BaseAPI}
 */
export class ActuatorApi extends BaseAPI {
  /**
   *
   * @summary Actuator web endpoint \'health\'
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActuatorApi
   */
  public health(options?: AxiosRequestConfig) {
    return ActuatorApiFp(this.configuration)
      .health(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Actuator web endpoint \'health-path\'
   * @param {string} path
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActuatorApi
   */
  public healthPath(path: string, options?: AxiosRequestConfig) {
    return ActuatorApiFp(this.configuration)
      .healthPath(path, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Actuator root web endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActuatorApi
   */
  public links(options?: AxiosRequestConfig) {
    return ActuatorApiFp(this.configuration)
      .links(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installPlugin: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('installPlugin', 'file', file)
      const localVarPath = `/apis/api.halo.run/v1alpha1/plugins/install`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1PluginApiAxiosParamCreator(configuration)
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async installPlugin(
      file: any,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.installPlugin(file, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1PluginApiFp(configuration)
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installPlugin(file: any, options?: any): AxiosPromise<void> {
      return localVarFp.installPlugin(file, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1PluginApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1PluginApi extends BaseAPI {
  /**
   * Install a plugin by uploading a Jar file.
   * @param {any} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1PluginApi
   */
  public installPlugin(file: any, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1PluginApiFp(this.configuration)
      .installPlugin(file, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      name: string,
      changePasswordRequest: ChangePasswordRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('changePassword', 'name', name)
      // verify required parameter 'changePasswordRequest' is not null or undefined
      assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/password`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/-`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getPermissions', 'name', name)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission: async (
      name: string,
      grantRequest: GrantRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('grantPermission', 'name', name)
      // verify required parameter 'grantRequest' is not null or undefined
      assertParamExists('grantPermission', 'grantRequest', grantRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(grantRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      name: string,
      changePasswordRequest: ChangePasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(name, changePasswordRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUserDetail(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserDetail(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPermissions(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPermission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissions(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grantPermission(
      name: string,
      grantRequest: GrantRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grantPermission(name, grantRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1UserApiFp(configuration)
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(name: string, changePasswordRequest: ChangePasswordRequest, options?: any): AxiosPromise<User> {
      return localVarFp.changePassword(name, changePasswordRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail(options?: any): AxiosPromise<User> {
      return localVarFp.getCurrentUserDetail(options).then((request) => request(axios, basePath))
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions(name: string, options?: any): AxiosPromise<UserPermission> {
      return localVarFp.getPermissions(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission(name: string, grantRequest: GrantRequest, options?: any): AxiosPromise<User> {
      return localVarFp.grantPermission(name, grantRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1UserApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1UserApi extends BaseAPI {
  /**
   * Change password of user.
   * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
   * @param {ChangePasswordRequest} changePasswordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public changePassword(name: string, changePasswordRequest: ChangePasswordRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .changePassword(name, changePasswordRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get current user detail
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getCurrentUserDetail(options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getCurrentUserDetail(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get permissions of user
   * @param {string} name User name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getPermissions(name: string, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getPermissions(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Grant permissions to user
   * @param {string} name User name
   * @param {GrantRequest} grantRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public grantPermission(name: string, grantRequest: GrantRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .grantPermission(name, grantRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin: async (
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin: async (
      name: string,
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1PluginApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1Plugin(
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1Plugin(plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1Plugin(
        page,
        size,
        sort,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1Plugin(
      name: string,
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1PluginApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp.createpluginHaloRunV1alpha1Plugin(plugin, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletepluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<Plugin> {
      return localVarFp.getpluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<PluginList> {
      return localVarFp
        .listpluginHaloRunV1alpha1Plugin(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp
        .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1PluginApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1PluginApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/Plugin
   * @param {Plugin} [plugin] Fresh plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .createpluginHaloRunV1alpha1Plugin(plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public deletepluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public getpluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .getpluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/Plugin
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public listpluginHaloRunV1alpha1Plugin(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .listpluginHaloRunV1alpha1Plugin(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {Plugin} [plugin] Updated plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy: async (
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1ReverseProxy(
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1ReverseProxy(
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxyList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1ReverseProxy(
        page,
        size,
        sort,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1ReverseProxy(
        name,
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1ReverseProxyApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp
        .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp.getpluginHaloRunV1alpha1ReverseProxy(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<ReverseProxyList> {
      return localVarFp
        .listpluginHaloRunV1alpha1ReverseProxy(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: any,
    ): AxiosPromise<ReverseProxy> {
      return localVarFp
        .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1ReverseProxyApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1ReverseProxyApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/ReverseProxy
   * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .getpluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/ReverseProxy
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public listpluginHaloRunV1alpha1ReverseProxy(
    page?: number,
    size?: number,
    sort?: string,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .listpluginHaloRunV1alpha1ReverseProxy(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public updatepluginHaloRunV1alpha1ReverseProxy(
    name: string,
    reverseProxy?: ReverseProxy,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1ConfigMapApi - axios parameter creator
 * @export
 */
export const V1alpha1ConfigMapApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap: async (configMap?: ConfigMap, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap: async (
      name: string,
      configMap?: ConfigMap,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1ConfigMapApi - functional programming interface
 * @export
 */
export const V1alpha1ConfigMapApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1ConfigMapApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1ConfigMap(
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1ConfigMap(configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1ConfigMap(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMapList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1ConfigMap(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1ConfigMap(
      name: string,
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1ConfigMap(name, configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1ConfigMapApi - factory interface
 * @export
 */
export const V1alpha1ConfigMapApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1ConfigMapApiFp(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap(configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.createv1alpha1ConfigMap(configMap, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap(name: string, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.getv1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<ConfigMapList> {
      return localVarFp.listv1alpha1ConfigMap(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.updatev1alpha1ConfigMap(name, configMap, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1ConfigMapApi - object-oriented interface
 * @export
 * @class V1alpha1ConfigMapApi
 * @extends {BaseAPI}
 */
export class V1alpha1ConfigMapApi extends BaseAPI {
  /**
   * Create v1alpha1/ConfigMap
   * @param {ConfigMap} [configMap] Fresh configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public createv1alpha1ConfigMap(configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .createv1alpha1ConfigMap(configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public deletev1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .deletev1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public getv1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .getv1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/ConfigMap
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public listv1alpha1ConfigMap(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .listv1alpha1ConfigMap(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {ConfigMap} [configMap] Updated configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .updatev1alpha1ConfigMap(name, configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - axios parameter creator
 * @export
 */
export const V1alpha1PersonalAccessTokenApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken: async (
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken: async (
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - functional programming interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1PersonalAccessTokenApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1PersonalAccessToken(
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessTokenList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1PersonalAccessToken(
        page,
        size,
        sort,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1PersonalAccessToken(
        name,
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - factory interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1PersonalAccessTokenApiFp(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .createv1alpha1PersonalAccessToken(personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<PersonalAccessToken> {
      return localVarFp.getv1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      sort?: string,
      options?: any,
    ): AxiosPromise<PersonalAccessTokenList> {
      return localVarFp
        .listv1alpha1PersonalAccessToken(page, size, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - object-oriented interface
 * @export
 * @class V1alpha1PersonalAccessTokenApi
 * @extends {BaseAPI}
 */
export class V1alpha1PersonalAccessTokenApi extends BaseAPI {
  /**
   * Create v1alpha1/PersonalAccessToken
   * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public createv1alpha1PersonalAccessToken(personalAccessToken?: PersonalAccessToken, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .createv1alpha1PersonalAccessToken(personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public deletev1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .deletev1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public getv1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .getv1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/PersonalAccessToken
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public listv1alpha1PersonalAccessToken(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .listv1alpha1PersonalAccessToken(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public updatev1alpha1PersonalAccessToken(
    name: string,
    personalAccessToken?: PersonalAccessToken,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role: async (role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role: async (name: string, role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleApi - functional programming interface
 * @export
 */
export const V1alpha1RoleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Role(
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Role(role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Role(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Role(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Role(
      name: string,
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Role(name, role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleApi - factory interface
 * @export
 */
export const V1alpha1RoleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role(role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.createv1alpha1Role(role, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role(name: string, options?: any): AxiosPromise<Role> {
      return localVarFp.getv1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<RoleList> {
      return localVarFp.listv1alpha1Role(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role(name: string, role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.updatev1alpha1Role(name, role, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleApi - object-oriented interface
 * @export
 * @class V1alpha1RoleApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleApi extends BaseAPI {
  /**
   * Create v1alpha1/Role
   * @param {Role} [role] Fresh role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public createv1alpha1Role(role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .createv1alpha1Role(role, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public deletev1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .deletev1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public getv1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .getv1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Role
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public listv1alpha1Role(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .listv1alpha1Role(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Role
   * @param {string} name Name of role
   * @param {Role} [role] Updated role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public updatev1alpha1Role(name: string, role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .updatev1alpha1Role(name, role, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleBindingApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleBindingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding: async (
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding: async (
      name: string,
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleBindingApi - functional programming interface
 * @export
 */
export const V1alpha1RoleBindingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleBindingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1RoleBinding(
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1RoleBinding(roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1RoleBinding(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBindingList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1RoleBinding(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1RoleBinding(
      name: string,
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1RoleBinding(name, roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleBindingApi - factory interface
 * @export
 */
export const V1alpha1RoleBindingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleBindingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.createv1alpha1RoleBinding(roleBinding, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding(name: string, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.getv1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<RoleBindingList> {
      return localVarFp.listv1alpha1RoleBinding(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp
        .updatev1alpha1RoleBinding(name, roleBinding, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleBindingApi - object-oriented interface
 * @export
 * @class V1alpha1RoleBindingApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleBindingApi extends BaseAPI {
  /**
   * Create v1alpha1/RoleBinding
   * @param {RoleBinding} [roleBinding] Fresh rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .createv1alpha1RoleBinding(roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public deletev1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .deletev1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public getv1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .getv1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/RoleBinding
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public listv1alpha1RoleBinding(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .listv1alpha1RoleBinding(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {RoleBinding} [roleBinding] Updated rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .updatev1alpha1RoleBinding(name, roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1SettingApi - axios parameter creator
 * @export
 */
export const V1alpha1SettingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting: async (setting?: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting: async (
      name: string,
      setting?: Setting,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1SettingApi - functional programming interface
 * @export
 */
export const V1alpha1SettingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1SettingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Setting(
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Setting(setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Setting(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Setting(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Setting(
      name: string,
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Setting(name, setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1SettingApi - factory interface
 * @export
 */
export const V1alpha1SettingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1SettingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting(setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.createv1alpha1Setting(setting, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting(name: string, options?: any): AxiosPromise<Setting> {
      return localVarFp.getv1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<SettingList> {
      return localVarFp.listv1alpha1Setting(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting(name: string, setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.updatev1alpha1Setting(name, setting, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1SettingApi - object-oriented interface
 * @export
 * @class V1alpha1SettingApi
 * @extends {BaseAPI}
 */
export class V1alpha1SettingApi extends BaseAPI {
  /**
   * Create v1alpha1/Setting
   * @param {Setting} [setting] Fresh setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public createv1alpha1Setting(setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .createv1alpha1Setting(setting, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public deletev1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .deletev1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public getv1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .getv1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Setting
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public listv1alpha1Setting(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .listv1alpha1Setting(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {Setting} [setting] Updated setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public updatev1alpha1Setting(name: string, setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .updatev1alpha1Setting(name, setting, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1UserApi - axios parameter creator
 * @export
 */
export const V1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User: async (
      page?: number,
      size?: number,
      sort?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User: async (name: string, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1UserApi - functional programming interface
 * @export
 */
export const V1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1User(
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1User(user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1User(
      page?: number,
      size?: number,
      sort?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1User(page, size, sort, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1User(
      name: string,
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1User(name, user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1UserApi - factory interface
 * @export
 */
export const V1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1UserApiFp(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User(user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.createv1alpha1User(user, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User(name: string, options?: any): AxiosPromise<User> {
      return localVarFp.getv1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] Page index
     * @param {number} [size] Size of one page
     * @param {string} [sort] Sort by some fields. Like metadata.name,desc
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User(page?: number, size?: number, sort?: string, options?: any): AxiosPromise<UserList> {
      return localVarFp.listv1alpha1User(page, size, sort, options).then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User(name: string, user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.updatev1alpha1User(name, user, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1UserApi - object-oriented interface
 * @export
 * @class V1alpha1UserApi
 * @extends {BaseAPI}
 */
export class V1alpha1UserApi extends BaseAPI {
  /**
   * Create v1alpha1/User
   * @param {User} [user] Fresh user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public createv1alpha1User(user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .createv1alpha1User(user, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public deletev1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .deletev1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public getv1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .getv1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/User
   * @param {number} [page] Page index
   * @param {number} [size] Size of one page
   * @param {string} [sort] Sort by some fields. Like metadata.name,desc
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public listv1alpha1User(page?: number, size?: number, sort?: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .listv1alpha1User(page, size, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/User
   * @param {string} name Name of user
   * @param {User} [user] Updated user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public updatev1alpha1User(name: string, user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .updatev1alpha1User(name, user, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
