/* tslint:disable */
/* eslint-disable */
/**
 * Halo Next API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface Attachment
 */
export interface Attachment {
  /**
   *
   * @type {AttachmentSpec}
   * @memberof Attachment
   */
  spec: AttachmentSpec
  /**
   *
   * @type {AttachmentStatus}
   * @memberof Attachment
   */
  status?: AttachmentStatus
  /**
   *
   * @type {string}
   * @memberof Attachment
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Attachment
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Attachment
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface AttachmentList
 */
export interface AttachmentList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof AttachmentList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof AttachmentList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof AttachmentList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Attachment>}
   * @memberof AttachmentList
   */
  items: Array<Attachment>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof AttachmentList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof AttachmentList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof AttachmentList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof AttachmentList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface AttachmentSpec
 */
export interface AttachmentSpec {
  /**
   * Display name of attachment
   * @type {string}
   * @memberof AttachmentSpec
   */
  displayName?: string
  /**
   *
   * @type {Ref}
   * @memberof AttachmentSpec
   */
  groupRef?: Ref
  /**
   *
   * @type {Ref}
   * @memberof AttachmentSpec
   */
  policyRef?: Ref
  /**
   *
   * @type {Ref}
   * @memberof AttachmentSpec
   */
  uploadedBy?: Ref
  /**
   * Media type of attachment
   * @type {string}
   * @memberof AttachmentSpec
   */
  mediaType?: string
  /**
   * Size of attachment. Unit is Byte
   * @type {number}
   * @memberof AttachmentSpec
   */
  size?: number
  /**
   * Tags of attachment
   * @type {Set<string>}
   * @memberof AttachmentSpec
   */
  tags?: Set<string>
}
/**
 *
 * @export
 * @interface AttachmentStatus
 */
export interface AttachmentStatus {
  /**
   * Permalink of attachment
   * @type {string}
   * @memberof AttachmentStatus
   */
  permalink?: string
}
/**
 *
 * @export
 * @interface Author
 */
export interface Author {
  /**
   *
   * @type {string}
   * @memberof Author
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof Author
   */
  website?: string
}
/**
 *
 * @export
 * @interface Category
 */
export interface Category {
  /**
   *
   * @type {CategorySpec}
   * @memberof Category
   */
  spec: CategorySpec
  /**
   *
   * @type {CategoryStatus}
   * @memberof Category
   */
  status?: CategoryStatus
  /**
   *
   * @type {string}
   * @memberof Category
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Category
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Category
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface CategoryList
 */
export interface CategoryList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof CategoryList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof CategoryList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof CategoryList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Category>}
   * @memberof CategoryList
   */
  items: Array<Category>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof CategoryList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof CategoryList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof CategoryList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof CategoryList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface CategorySpec
 */
export interface CategorySpec {
  /**
   *
   * @type {string}
   * @memberof CategorySpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof CategorySpec
   */
  slug: string
  /**
   *
   * @type {string}
   * @memberof CategorySpec
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof CategorySpec
   */
  cover?: string
  /**
   *
   * @type {string}
   * @memberof CategorySpec
   */
  template?: string
  /**
   *
   * @type {number}
   * @memberof CategorySpec
   */
  priority: number
  /**
   *
   * @type {Array<string>}
   * @memberof CategorySpec
   */
  children?: Array<string>
}
/**
 *
 * @export
 * @interface CategoryStatus
 */
export interface CategoryStatus {
  /**
   *
   * @type {string}
   * @memberof CategoryStatus
   */
  permalink?: string
  /**
   *
   * @type {Array<string>}
   * @memberof CategoryStatus
   */
  posts?: Array<string>
}
/**
 *
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
  /**
   * New password.
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface Comment
 */
export interface Comment {
  /**
   *
   * @type {CommentSpec}
   * @memberof Comment
   */
  spec: CommentSpec
  /**
   *
   * @type {string}
   * @memberof Comment
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Comment
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Comment
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface CommentList
 */
export interface CommentList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof CommentList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof CommentList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof CommentList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Comment>}
   * @memberof CommentList
   */
  items: Array<Comment>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof CommentList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof CommentList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof CommentList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof CommentList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface CommentOwner
 */
export interface CommentOwner {
  /**
   *
   * @type {string}
   * @memberof CommentOwner
   */
  kind: string
  /**
   *
   * @type {string}
   * @memberof CommentOwner
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CommentOwner
   */
  displayName?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CommentOwner
   */
  annotations?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface CommentSpec
 */
export interface CommentSpec {
  /**
   *
   * @type {string}
   * @memberof CommentSpec
   */
  raw: string
  /**
   *
   * @type {string}
   * @memberof CommentSpec
   */
  content: string
  /**
   *
   * @type {CommentOwner}
   * @memberof CommentSpec
   */
  owner: CommentOwner
  /**
   *
   * @type {string}
   * @memberof CommentSpec
   */
  userAgent?: string
  /**
   *
   * @type {string}
   * @memberof CommentSpec
   */
  ipAddress?: string
  /**
   *
   * @type {number}
   * @memberof CommentSpec
   */
  priority: number
  /**
   *
   * @type {boolean}
   * @memberof CommentSpec
   */
  top: boolean
  /**
   *
   * @type {boolean}
   * @memberof CommentSpec
   */
  allowNotification: boolean
  /**
   *
   * @type {boolean}
   * @memberof CommentSpec
   */
  approved: boolean
  /**
   *
   * @type {boolean}
   * @memberof CommentSpec
   */
  hidden: boolean
  /**
   *
   * @type {CommentSubjectRef}
   * @memberof CommentSpec
   */
  subjectRef: CommentSubjectRef
}
/**
 *
 * @export
 * @interface CommentSubjectRef
 */
export interface CommentSubjectRef {
  /**
   *
   * @type {string}
   * @memberof CommentSubjectRef
   */
  kind: string
  /**
   *
   * @type {string}
   * @memberof CommentSubjectRef
   */
  name: string
}
/**
 *
 * @export
 * @interface Condition
 */
export interface Condition {
  /**
   *
   * @type {string}
   * @memberof Condition
   */
  type: string
  /**
   *
   * @type {string}
   * @memberof Condition
   */
  status: ConditionStatusEnum
  /**
   *
   * @type {string}
   * @memberof Condition
   */
  lastTransitionTime: string
  /**
   *
   * @type {string}
   * @memberof Condition
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof Condition
   */
  reason: string
}

export const ConditionStatusEnum = {
  True: 'TRUE',
  False: 'FALSE',
  Unknown: 'UNKNOWN',
} as const

export type ConditionStatusEnum = typeof ConditionStatusEnum[keyof typeof ConditionStatusEnum]

/**
 *
 * @export
 * @interface ConfigMap
 */
export interface ConfigMap {
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof ConfigMap
   */
  data?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ConfigMap
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ConfigMap
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ConfigMapList
 */
export interface ConfigMapList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ConfigMapList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ConfigMapList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ConfigMapList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<ConfigMap>}
   * @memberof ConfigMapList
   */
  items: Array<ConfigMap>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ConfigMapList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface Content
 */
export interface Content {
  /**
   *
   * @type {string}
   * @memberof Content
   */
  raw?: string
  /**
   *
   * @type {string}
   * @memberof Content
   */
  content?: string
  /**
   *
   * @type {string}
   * @memberof Content
   */
  rawType?: string
}
/**
 *
 * @export
 * @interface ContentRequest
 */
export interface ContentRequest {
  /**
   *
   * @type {SubjectRef}
   * @memberof ContentRequest
   */
  subjectRef: SubjectRef
  /**
   *
   * @type {string}
   * @memberof ContentRequest
   */
  headSnapshotName?: string
  /**
   *
   * @type {string}
   * @memberof ContentRequest
   */
  raw: string
  /**
   *
   * @type {string}
   * @memberof ContentRequest
   */
  content: string
  /**
   *
   * @type {string}
   * @memberof ContentRequest
   */
  rawType: string
}
/**
 *
 * @export
 * @interface ContentWrapper
 */
export interface ContentWrapper {
  /**
   *
   * @type {string}
   * @memberof ContentWrapper
   */
  snapshotName: string
  /**
   *
   * @type {string}
   * @memberof ContentWrapper
   */
  raw: string
  /**
   *
   * @type {string}
   * @memberof ContentWrapper
   */
  content: string
  /**
   *
   * @type {string}
   * @memberof ContentWrapper
   */
  rawType: string
}
/**
 *
 * @export
 * @interface Contributor
 */
export interface Contributor {
  /**
   *
   * @type {string}
   * @memberof Contributor
   */
  displayName?: string
  /**
   *
   * @type {string}
   * @memberof Contributor
   */
  avatar?: string
  /**
   *
   * @type {string}
   * @memberof Contributor
   */
  name?: string
}
/**
 *
 * @export
 * @interface Excerpt
 */
export interface Excerpt {
  /**
   *
   * @type {boolean}
   * @memberof Excerpt
   */
  autoGenerate: boolean
  /**
   *
   * @type {string}
   * @memberof Excerpt
   */
  raw?: string
}
/**
 *
 * @export
 * @interface FileReverseProxyProvider
 */
export interface FileReverseProxyProvider {
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  directory?: string
  /**
   *
   * @type {string}
   * @memberof FileReverseProxyProvider
   */
  filename?: string
}
/**
 *
 * @export
 * @interface GrantRequest
 */
export interface GrantRequest {
  /**
   *
   * @type {Set<string>}
   * @memberof GrantRequest
   */
  roles?: Set<string>
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
  /**
   *
   * @type {GroupSpec}
   * @memberof Group
   */
  spec: GroupSpec
  /**
   *
   * @type {GroupStatus}
   * @memberof Group
   */
  status?: GroupStatus
  /**
   *
   * @type {string}
   * @memberof Group
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Group
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Group
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface GroupList
 */
export interface GroupList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof GroupList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof GroupList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof GroupList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Group>}
   * @memberof GroupList
   */
  items: Array<Group>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof GroupList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof GroupList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof GroupList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof GroupList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface GroupSpec
 */
export interface GroupSpec {
  /**
   * Display name of group
   * @type {string}
   * @memberof GroupSpec
   */
  displayName: string
}
/**
 *
 * @export
 * @interface GroupStatus
 */
export interface GroupStatus {
  /**
   * Update timestamp of the group
   * @type {string}
   * @memberof GroupStatus
   */
  updateTimestamp?: string
  /**
   * Total of attachments under the current group
   * @type {number}
   * @memberof GroupStatus
   */
  totalAttachments?: number
}
/**
 *
 * @export
 * @interface License
 */
export interface License {
  /**
   *
   * @type {string}
   * @memberof License
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof License
   */
  url?: string
}
/**
 * A chunk of items.
 * @export
 * @interface ListedPost
 */
export interface ListedPost {
  /**
   *
   * @type {Post}
   * @memberof ListedPost
   */
  post: Post
  /**
   *
   * @type {Array<Category>}
   * @memberof ListedPost
   */
  categories: Array<Category>
  /**
   *
   * @type {Array<Tag>}
   * @memberof ListedPost
   */
  tags: Array<Tag>
  /**
   *
   * @type {Array<Contributor>}
   * @memberof ListedPost
   */
  contributors: Array<Contributor>
}
/**
 *
 * @export
 * @interface ListedPostList
 */
export interface ListedPostList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ListedPostList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ListedPostList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ListedPostList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<ListedPost>}
   * @memberof ListedPostList
   */
  items: Array<ListedPost>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ListedPostList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ListedPostList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ListedPostList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ListedPostList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface LoginHistory
 */
export interface LoginHistory {
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  loginAt: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  sourceIp: string
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  userAgent: string
  /**
   *
   * @type {boolean}
   * @memberof LoginHistory
   */
  successful: boolean
  /**
   *
   * @type {string}
   * @memberof LoginHistory
   */
  reason?: string
}
/**
 *
 * @export
 * @interface Menu
 */
export interface Menu {
  /**
   *
   * @type {MenuSpec}
   * @memberof Menu
   */
  spec: MenuSpec
  /**
   *
   * @type {string}
   * @memberof Menu
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Menu
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Menu
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface MenuItem
 */
export interface MenuItem {
  /**
   *
   * @type {MenuItemSpec}
   * @memberof MenuItem
   */
  spec: MenuItemSpec
  /**
   *
   * @type {MenuItemStatus}
   * @memberof MenuItem
   */
  status?: MenuItemStatus
  /**
   *
   * @type {string}
   * @memberof MenuItem
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof MenuItem
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof MenuItem
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface MenuItemList
 */
export interface MenuItemList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuItemList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuItemList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof MenuItemList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<MenuItem>}
   * @memberof MenuItemList
   */
  items: Array<MenuItem>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuItemList
   */
  hasPrevious: boolean
}
/**
 * Page reference.
 * @export
 * @interface MenuItemRef
 */
export interface MenuItemRef {
  /**
   * Reference name.
   * @type {string}
   * @memberof MenuItemRef
   */
  name: string
}
/**
 * The spec of menu item.
 * @export
 * @interface MenuItemSpec
 */
export interface MenuItemSpec {
  /**
   * The display name of menu item.
   * @type {string}
   * @memberof MenuItemSpec
   */
  displayName?: string
  /**
   * The href of this menu item.
   * @type {string}
   * @memberof MenuItemSpec
   */
  href?: string
  /**
   * The priority is for ordering.
   * @type {number}
   * @memberof MenuItemSpec
   */
  priority?: number
  /**
   * Children of this menu item
   * @type {Set<string>}
   * @memberof MenuItemSpec
   */
  children?: Set<string>
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  categoryRef?: MenuItemRef
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  tagRef?: MenuItemRef
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  postRef?: MenuItemRef
  /**
   *
   * @type {MenuItemRef}
   * @memberof MenuItemSpec
   */
  pageRef?: MenuItemRef
}
/**
 * The status of menu item.
 * @export
 * @interface MenuItemStatus
 */
export interface MenuItemStatus {
  /**
   * Calculated Display name of menu item.
   * @type {string}
   * @memberof MenuItemStatus
   */
  displayName?: string
  /**
   * Calculated href of manu item.
   * @type {string}
   * @memberof MenuItemStatus
   */
  href?: string
}
/**
 *
 * @export
 * @interface MenuList
 */
export interface MenuList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof MenuList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof MenuList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Menu>}
   * @memberof MenuList
   */
  items: Array<Menu>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof MenuList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof MenuList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof MenuList
   */
  hasPrevious: boolean
}
/**
 * The spec of menu.
 * @export
 * @interface MenuSpec
 */
export interface MenuSpec {
  /**
   * The display name of the menu.
   * @type {string}
   * @memberof MenuSpec
   */
  displayName: string
  /**
   * Names of menu children below this menu.
   * @type {Set<string>}
   * @memberof MenuSpec
   */
  menuItems?: Set<string>
}
/**
 *
 * @export
 * @interface Metadata
 */
export interface Metadata {
  /**
   *
   * @type {Set<string>}
   * @memberof Metadata
   */
  finalizers?: Set<string> | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  name: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  labels?: { [key: string]: string } | null
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof Metadata
   */
  annotations?: { [key: string]: string } | null
  /**
   *
   * @type {number}
   * @memberof Metadata
   */
  version?: number | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  creationTimestamp?: string | null
  /**
   *
   * @type {string}
   * @memberof Metadata
   */
  deletionTimestamp?: string | null
}
/**
 *
 * @export
 * @interface PersonalAccessToken
 */
export interface PersonalAccessToken {
  /**
   *
   * @type {PersonalAccessTokenSpec}
   * @memberof PersonalAccessToken
   */
  spec?: PersonalAccessTokenSpec
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessToken
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof PersonalAccessToken
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PersonalAccessTokenList
 */
export interface PersonalAccessTokenList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PersonalAccessTokenList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<PersonalAccessToken>}
   * @memberof PersonalAccessTokenList
   */
  items: Array<PersonalAccessToken>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PersonalAccessTokenList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PersonalAccessTokenSpec
 */
export interface PersonalAccessTokenSpec {
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  userName?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  displayName?: string
  /**
   *
   * @type {boolean}
   * @memberof PersonalAccessTokenSpec
   */
  revoked?: boolean
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  expiresAt?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  scopes?: string
  /**
   *
   * @type {string}
   * @memberof PersonalAccessTokenSpec
   */
  tokenDigest?: string
}
/**
 *
 * @export
 * @interface Plugin
 */
export interface Plugin {
  /**
   *
   * @type {PluginSpec}
   * @memberof Plugin
   */
  spec: PluginSpec
  /**
   *
   * @type {PluginStatus}
   * @memberof Plugin
   */
  status?: PluginStatus
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Plugin
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Plugin
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PluginList
 */
export interface PluginList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PluginList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PluginList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PluginList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Plugin>}
   * @memberof PluginList
   */
  items: Array<Plugin>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PluginList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PluginList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PluginList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PluginList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PluginSpec
 */
export interface PluginSpec {
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  displayName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  version?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  author?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  logo?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PluginSpec
   */
  pluginDependencies?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  homepage?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  description?: string
  /**
   *
   * @type {Array<License>}
   * @memberof PluginSpec
   */
  license?: Array<License>
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  requires?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   * @deprecated
   */
  pluginClass?: string
  /**
   *
   * @type {boolean}
   * @memberof PluginSpec
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  settingName?: string
  /**
   *
   * @type {string}
   * @memberof PluginSpec
   */
  configMapName?: string
}
/**
 *
 * @export
 * @interface PluginStatus
 */
export interface PluginStatus {
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  phase?: PluginStatusPhaseEnum
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  reason?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastStartTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  lastTransitionTime?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  entry?: string
  /**
   *
   * @type {string}
   * @memberof PluginStatus
   */
  stylesheet?: string
}

export const PluginStatusPhaseEnum = {
  Created: 'CREATED',
  Disabled: 'DISABLED',
  Resolved: 'RESOLVED',
  Started: 'STARTED',
  Stopped: 'STOPPED',
  Failed: 'FAILED',
} as const

export type PluginStatusPhaseEnum = typeof PluginStatusPhaseEnum[keyof typeof PluginStatusPhaseEnum]

/**
 *
 * @export
 * @interface Policy
 */
export interface Policy {
  /**
   *
   * @type {PolicySpec}
   * @memberof Policy
   */
  spec: PolicySpec
  /**
   *
   * @type {string}
   * @memberof Policy
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Policy
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Policy
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PolicyList
 */
export interface PolicyList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PolicyList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PolicyList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PolicyList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Policy>}
   * @memberof PolicyList
   */
  items: Array<Policy>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PolicyList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PolicyList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PolicyList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PolicyList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PolicyRule
 */
export interface PolicyRule {
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  apiGroups?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resources?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  resourceNames?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  nonResourceURLs?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyRule
   */
  verbs?: Array<string>
}
/**
 *
 * @export
 * @interface PolicySpec
 */
export interface PolicySpec {
  /**
   * Display name of policy
   * @type {string}
   * @memberof PolicySpec
   */
  displayName: string
  /**
   *
   * @type {Ref}
   * @memberof PolicySpec
   */
  templateRef?: Ref
  /**
   *
   * @type {Ref}
   * @memberof PolicySpec
   */
  configMapRef?: Ref
}
/**
 *
 * @export
 * @interface PolicyTemplate
 */
export interface PolicyTemplate {
  /**
   *
   * @type {PolicyTemplateSpec}
   * @memberof PolicyTemplate
   */
  spec?: PolicyTemplateSpec
  /**
   *
   * @type {string}
   * @memberof PolicyTemplate
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof PolicyTemplate
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof PolicyTemplate
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PolicyTemplateList
 */
export interface PolicyTemplateList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PolicyTemplateList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PolicyTemplateList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PolicyTemplateList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<PolicyTemplate>}
   * @memberof PolicyTemplateList
   */
  items: Array<PolicyTemplate>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PolicyTemplateList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PolicyTemplateList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PolicyTemplateList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PolicyTemplateList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PolicyTemplateSpec
 */
export interface PolicyTemplateSpec {
  /**
   *
   * @type {string}
   * @memberof PolicyTemplateSpec
   */
  displayName?: string
  /**
   *
   * @type {Ref}
   * @memberof PolicyTemplateSpec
   */
  settingRef?: Ref
}
/**
 *
 * @export
 * @interface Post
 */
export interface Post {
  /**
   *
   * @type {PostSpec}
   * @memberof Post
   */
  spec: PostSpec
  /**
   *
   * @type {PostStatus}
   * @memberof Post
   */
  status?: PostStatus
  /**
   *
   * @type {string}
   * @memberof Post
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Post
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Post
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface PostList
 */
export interface PostList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PostList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof PostList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof PostList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Post>}
   * @memberof PostList
   */
  items: Array<Post>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof PostList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof PostList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PostList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof PostList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface PostRequest
 */
export interface PostRequest {
  /**
   *
   * @type {Post}
   * @memberof PostRequest
   */
  post: Post
  /**
   *
   * @type {Content}
   * @memberof PostRequest
   */
  content: Content
}
/**
 *
 * @export
 * @interface PostSpec
 */
export interface PostSpec {
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  slug: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  releaseSnapshot?: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  headSnapshot?: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  baseSnapshot?: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  owner?: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  template?: string
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  cover?: string
  /**
   *
   * @type {boolean}
   * @memberof PostSpec
   */
  deleted: boolean
  /**
   *
   * @type {boolean}
   * @memberof PostSpec
   */
  published: boolean
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  publishTime?: string
  /**
   *
   * @type {boolean}
   * @memberof PostSpec
   */
  pinned: boolean
  /**
   *
   * @type {boolean}
   * @memberof PostSpec
   */
  allowComment: boolean
  /**
   *
   * @type {string}
   * @memberof PostSpec
   */
  visible: PostSpecVisibleEnum
  /**
   *
   * @type {number}
   * @memberof PostSpec
   */
  version: number
  /**
   *
   * @type {number}
   * @memberof PostSpec
   */
  priority: number
  /**
   *
   * @type {Excerpt}
   * @memberof PostSpec
   */
  excerpt: Excerpt
  /**
   *
   * @type {Array<string>}
   * @memberof PostSpec
   */
  categories?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PostSpec
   */
  tags?: Array<string>
  /**
   *
   * @type {Array<{ [key: string]: string; }>}
   * @memberof PostSpec
   */
  htmlMetas?: Array<{ [key: string]: string }>
}

export const PostSpecVisibleEnum = {
  Public: 'PUBLIC',
  Internal: 'INTERNAL',
  Private: 'PRIVATE',
} as const

export type PostSpecVisibleEnum = typeof PostSpecVisibleEnum[keyof typeof PostSpecVisibleEnum]

/**
 *
 * @export
 * @interface PostStatus
 */
export interface PostStatus {
  /**
   *
   * @type {string}
   * @memberof PostStatus
   */
  phase: string
  /**
   *
   * @type {Array<Condition>}
   * @memberof PostStatus
   */
  conditions?: Array<Condition>
  /**
   *
   * @type {string}
   * @memberof PostStatus
   */
  permalink?: string
  /**
   *
   * @type {string}
   * @memberof PostStatus
   */
  excerpt?: string
  /**
   *
   * @type {boolean}
   * @memberof PostStatus
   */
  inProgress?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof PostStatus
   */
  contributors?: Array<string>
}
/**
 * Extension reference object. The name is mandatory
 * @export
 * @interface Ref
 */
export interface Ref {
  /**
   * Extension group
   * @type {string}
   * @memberof Ref
   */
  group?: string
  /**
   * Extension version
   * @type {string}
   * @memberof Ref
   */
  version?: string
  /**
   * Extension kind
   * @type {string}
   * @memberof Ref
   */
  kind?: string
  /**
   * Extension name. This field is mandatory
   * @type {string}
   * @memberof Ref
   */
  name: string
}
/**
 *
 * @export
 * @interface Reply
 */
export interface Reply {
  /**
   *
   * @type {ReplySpec}
   * @memberof Reply
   */
  spec: ReplySpec
  /**
   *
   * @type {string}
   * @memberof Reply
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Reply
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Reply
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ReplyList
 */
export interface ReplyList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReplyList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReplyList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ReplyList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Reply>}
   * @memberof ReplyList
   */
  items: Array<Reply>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ReplyList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ReplyList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReplyList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReplyList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface ReplySpec
 */
export interface ReplySpec {
  /**
   *
   * @type {string}
   * @memberof ReplySpec
   */
  raw: string
  /**
   *
   * @type {string}
   * @memberof ReplySpec
   */
  content: string
  /**
   *
   * @type {CommentOwner}
   * @memberof ReplySpec
   */
  owner: CommentOwner
  /**
   *
   * @type {string}
   * @memberof ReplySpec
   */
  userAgent?: string
  /**
   *
   * @type {string}
   * @memberof ReplySpec
   */
  ipAddress?: string
  /**
   *
   * @type {number}
   * @memberof ReplySpec
   */
  priority: number
  /**
   *
   * @type {boolean}
   * @memberof ReplySpec
   */
  top: boolean
  /**
   *
   * @type {boolean}
   * @memberof ReplySpec
   */
  allowNotification: boolean
  /**
   *
   * @type {boolean}
   * @memberof ReplySpec
   */
  approved: boolean
  /**
   *
   * @type {boolean}
   * @memberof ReplySpec
   */
  hidden: boolean
  /**
   *
   * @type {string}
   * @memberof ReplySpec
   */
  commentName: string
  /**
   *
   * @type {string}
   * @memberof ReplySpec
   */
  quoteReply?: string
}
/**
 *
 * @export
 * @interface ReverseProxy
 */
export interface ReverseProxy {
  /**
   *
   * @type {Array<ReverseProxyRule>}
   * @memberof ReverseProxy
   */
  rules?: Array<ReverseProxyRule>
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof ReverseProxy
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof ReverseProxy
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ReverseProxyList
 */
export interface ReverseProxyList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReverseProxyList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ReverseProxyList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ReverseProxyList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<ReverseProxy>}
   * @memberof ReverseProxyList
   */
  items: Array<ReverseProxy>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ReverseProxyList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface ReverseProxyRule
 */
export interface ReverseProxyRule {
  /**
   *
   * @type {string}
   * @memberof ReverseProxyRule
   */
  path?: string
  /**
   *
   * @type {FileReverseProxyProvider}
   * @memberof ReverseProxyRule
   */
  file?: FileReverseProxyProvider
}
/**
 *
 * @export
 * @interface Role
 */
export interface Role {
  /**
   *
   * @type {Array<PolicyRule>}
   * @memberof Role
   */
  rules: Array<PolicyRule>
  /**
   *
   * @type {string}
   * @memberof Role
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Role
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Role
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleBinding
 */
export interface RoleBinding {
  /**
   *
   * @type {Array<Subject>}
   * @memberof RoleBinding
   */
  subjects?: Array<Subject>
  /**
   *
   * @type {RoleRef}
   * @memberof RoleBinding
   */
  roleRef?: RoleRef
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof RoleBinding
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof RoleBinding
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface RoleBindingList
 */
export interface RoleBindingList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleBindingList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleBindingList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof RoleBindingList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<RoleBinding>}
   * @memberof RoleBindingList
   */
  items: Array<RoleBinding>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleBindingList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface RoleList
 */
export interface RoleList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof RoleList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof RoleList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Role>}
   * @memberof RoleList
   */
  items: Array<Role>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof RoleList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof RoleList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof RoleList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface RoleRef
 */
export interface RoleRef {
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof RoleRef
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface Setting
 */
export interface Setting {
  /**
   *
   * @type {Array<SettingSpec>}
   * @memberof Setting
   */
  spec: Array<SettingSpec>
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Setting
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Setting
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface SettingList
 */
export interface SettingList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SettingList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SettingList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof SettingList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Setting>}
   * @memberof SettingList
   */
  items: Array<Setting>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof SettingList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof SettingList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SettingList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SettingList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface SettingSpec
 */
export interface SettingSpec {
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  group: string
  /**
   *
   * @type {string}
   * @memberof SettingSpec
   */
  label?: string
  /**
   *
   * @type {Array<object>}
   * @memberof SettingSpec
   */
  formSchema?: Array<object>
}
/**
 *
 * @export
 * @interface SnapShotSpec
 */
export interface SnapShotSpec {
  /**
   *
   * @type {SubjectRef}
   * @memberof SnapShotSpec
   */
  subjectRef: SubjectRef
  /**
   *
   * @type {string}
   * @memberof SnapShotSpec
   */
  rawType: string
  /**
   *
   * @type {string}
   * @memberof SnapShotSpec
   */
  rawPatch?: string
  /**
   *
   * @type {string}
   * @memberof SnapShotSpec
   */
  contentPatch?: string
  /**
   *
   * @type {string}
   * @memberof SnapShotSpec
   */
  parentSnapshotName?: string
  /**
   *
   * @type {string}
   * @memberof SnapShotSpec
   */
  displayVersion: string
  /**
   *
   * @type {number}
   * @memberof SnapShotSpec
   */
  version: number
  /**
   *
   * @type {string}
   * @memberof SnapShotSpec
   */
  publishTime?: string
  /**
   *
   * @type {Set<string>}
   * @memberof SnapShotSpec
   */
  contributors?: Set<string>
}
/**
 *
 * @export
 * @interface Snapshot
 */
export interface Snapshot {
  /**
   *
   * @type {SnapShotSpec}
   * @memberof Snapshot
   */
  spec: SnapShotSpec
  /**
   *
   * @type {string}
   * @memberof Snapshot
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Snapshot
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Snapshot
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface SnapshotList
 */
export interface SnapshotList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SnapshotList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof SnapshotList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof SnapshotList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Snapshot>}
   * @memberof SnapshotList
   */
  items: Array<Snapshot>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof SnapshotList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof SnapshotList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SnapshotList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof SnapshotList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface Subject
 */
export interface Subject {
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  kind?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Subject
   */
  apiGroup?: string
}
/**
 *
 * @export
 * @interface SubjectRef
 */
export interface SubjectRef {
  /**
   *
   * @type {string}
   * @memberof SubjectRef
   */
  kind: string
  /**
   *
   * @type {string}
   * @memberof SubjectRef
   */
  name: string
}
/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
  /**
   *
   * @type {TagSpec}
   * @memberof Tag
   */
  spec: TagSpec
  /**
   *
   * @type {TagStatus}
   * @memberof Tag
   */
  status?: TagStatus
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Tag
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface TagList
 */
export interface TagList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof TagList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof TagList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof TagList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Tag>}
   * @memberof TagList
   */
  items: Array<Tag>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof TagList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof TagList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof TagList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof TagList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface TagSpec
 */
export interface TagSpec {
  /**
   *
   * @type {string}
   * @memberof TagSpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof TagSpec
   */
  slug: string
  /**
   *
   * @type {string}
   * @memberof TagSpec
   */
  color?: string
  /**
   *
   * @type {string}
   * @memberof TagSpec
   */
  cover?: string
}
/**
 *
 * @export
 * @interface TagStatus
 */
export interface TagStatus {
  /**
   *
   * @type {string}
   * @memberof TagStatus
   */
  permalink?: string
  /**
   *
   * @type {Array<string>}
   * @memberof TagStatus
   */
  posts?: Array<string>
}
/**
 *
 * @export
 * @interface Theme
 */
export interface Theme {
  /**
   *
   * @type {ThemeSpec}
   * @memberof Theme
   */
  spec: ThemeSpec
  /**
   *
   * @type {string}
   * @memberof Theme
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof Theme
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof Theme
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface ThemeList
 */
export interface ThemeList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ThemeList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof ThemeList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof ThemeList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<Theme>}
   * @memberof ThemeList
   */
  items: Array<Theme>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof ThemeList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof ThemeList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ThemeList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof ThemeList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface ThemeSpec
 */
export interface ThemeSpec {
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  displayName: string
  /**
   *
   * @type {Author}
   * @memberof ThemeSpec
   */
  author: Author
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  logo?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  website?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  repo?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  version: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  require: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  settingName?: string
  /**
   *
   * @type {string}
   * @memberof ThemeSpec
   */
  configMapName?: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {UserSpec}
   * @memberof User
   */
  spec: UserSpec
  /**
   *
   * @type {UserStatus}
   * @memberof User
   */
  status?: UserStatus
  /**
   *
   * @type {string}
   * @memberof User
   */
  apiVersion: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  kind: string
  /**
   *
   * @type {Metadata}
   * @memberof User
   */
  metadata: Metadata
}
/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   * Page number, starts from 1. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof UserList
   */
  page: number
  /**
   * Size of each page. If not set or equal to 0, it means no pagination.
   * @type {number}
   * @memberof UserList
   */
  size: number
  /**
   * Total elements.
   * @type {number}
   * @memberof UserList
   */
  total: number
  /**
   * A chunk of items.
   * @type {Array<User>}
   * @memberof UserList
   */
  items: Array<User>
  /**
   * Indicates whether current page is the first page.
   * @type {boolean}
   * @memberof UserList
   */
  first: boolean
  /**
   * Indicates whether current page is the last page.
   * @type {boolean}
   * @memberof UserList
   */
  last: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof UserList
   */
  hasNext: boolean
  /**
   * Indicates whether current page has previous page.
   * @type {boolean}
   * @memberof UserList
   */
  hasPrevious: boolean
}
/**
 *
 * @export
 * @interface UserPermission
 */
export interface UserPermission {
  /**
   *
   * @type {Set<Role>}
   * @memberof UserPermission
   */
  roles: Set<Role>
  /**
   *
   * @type {Set<string>}
   * @memberof UserPermission
   */
  uiPermissions: Set<string>
}
/**
 *
 * @export
 * @interface UserSpec
 */
export interface UserSpec {
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  displayName: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  avatar?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  phone?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  bio?: string
  /**
   *
   * @type {string}
   * @memberof UserSpec
   */
  registeredAt?: string
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  twoFactorAuthEnabled?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UserSpec
   */
  disabled?: boolean
  /**
   *
   * @type {number}
   * @memberof UserSpec
   */
  loginHistoryLimit?: number
}
/**
 *
 * @export
 * @interface UserStatus
 */
export interface UserStatus {
  /**
   *
   * @type {string}
   * @memberof UserStatus
   */
  lastLoginAt?: string
  /**
   *
   * @type {Array<LoginHistory>}
   * @memberof UserStatus
   */
  loginHistories?: Array<LoginHistory>
}

/**
 * ApiHaloRunV1alpha1ContentApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1ContentApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Draft a snapshot content.
     * @param {ContentRequest} contentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftSnapshotContent: async (
      contentRequest: ContentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'contentRequest' is not null or undefined
      assertParamExists('draftSnapshotContent', 'contentRequest', contentRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/contents`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(contentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Obtain a snapshot content.
     * @param {string} snapshotName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obtainSnapshotContent: async (snapshotName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'snapshotName' is not null or undefined
      assertParamExists('obtainSnapshotContent', 'snapshotName', snapshotName)
      const localVarPath = `/apis/api.halo.run/v1alpha1/contents/{snapshotName}`.replace(
        `{${'snapshotName'}}`,
        encodeURIComponent(String(snapshotName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Publish a snapshot content.
     * @param {string} snapshotName
     * @param {SubjectRef} subjectRef
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishSnapshotContent: async (
      snapshotName: string,
      subjectRef: SubjectRef,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'snapshotName' is not null or undefined
      assertParamExists('publishSnapshotContent', 'snapshotName', snapshotName)
      // verify required parameter 'subjectRef' is not null or undefined
      assertParamExists('publishSnapshotContent', 'subjectRef', subjectRef)
      const localVarPath = `/apis/api.halo.run/v1alpha1/contents/{snapshotName}/publish`.replace(
        `{${'snapshotName'}}`,
        encodeURIComponent(String(snapshotName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(subjectRef, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update a snapshot content.
     * @param {string} snapshotName
     * @param {ContentRequest} contentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSnapshotContent: async (
      snapshotName: string,
      contentRequest: ContentRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'snapshotName' is not null or undefined
      assertParamExists('updateSnapshotContent', 'snapshotName', snapshotName)
      // verify required parameter 'contentRequest' is not null or undefined
      assertParamExists('updateSnapshotContent', 'contentRequest', contentRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/contents/{snapshotName}`.replace(
        `{${'snapshotName'}}`,
        encodeURIComponent(String(snapshotName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(contentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1ContentApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1ContentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1ContentApiAxiosParamCreator(configuration)
  return {
    /**
     * Draft a snapshot content.
     * @param {ContentRequest} contentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async draftSnapshotContent(
      contentRequest: ContentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentWrapper>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.draftSnapshotContent(contentRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Obtain a snapshot content.
     * @param {string} snapshotName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async obtainSnapshotContent(
      snapshotName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentWrapper>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.obtainSnapshotContent(snapshotName, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Publish a snapshot content.
     * @param {string} snapshotName
     * @param {SubjectRef} subjectRef
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishSnapshotContent(
      snapshotName: string,
      subjectRef: SubjectRef,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentWrapper>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publishSnapshotContent(
        snapshotName,
        subjectRef,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update a snapshot content.
     * @param {string} snapshotName
     * @param {ContentRequest} contentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSnapshotContent(
      snapshotName: string,
      contentRequest: ContentRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentWrapper>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSnapshotContent(
        snapshotName,
        contentRequest,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1ContentApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1ContentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1ContentApiFp(configuration)
  return {
    /**
     * Draft a snapshot content.
     * @param {ContentRequest} contentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftSnapshotContent(contentRequest: ContentRequest, options?: any): AxiosPromise<ContentWrapper> {
      return localVarFp.draftSnapshotContent(contentRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Obtain a snapshot content.
     * @param {string} snapshotName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obtainSnapshotContent(snapshotName: string, options?: any): AxiosPromise<ContentWrapper> {
      return localVarFp.obtainSnapshotContent(snapshotName, options).then((request) => request(axios, basePath))
    },
    /**
     * Publish a snapshot content.
     * @param {string} snapshotName
     * @param {SubjectRef} subjectRef
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishSnapshotContent(snapshotName: string, subjectRef: SubjectRef, options?: any): AxiosPromise<ContentWrapper> {
      return localVarFp
        .publishSnapshotContent(snapshotName, subjectRef, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update a snapshot content.
     * @param {string} snapshotName
     * @param {ContentRequest} contentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSnapshotContent(
      snapshotName: string,
      contentRequest: ContentRequest,
      options?: any,
    ): AxiosPromise<ContentWrapper> {
      return localVarFp
        .updateSnapshotContent(snapshotName, contentRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1ContentApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1ContentApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1ContentApi extends BaseAPI {
  /**
   * Draft a snapshot content.
   * @param {ContentRequest} contentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1ContentApi
   */
  public draftSnapshotContent(contentRequest: ContentRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1ContentApiFp(this.configuration)
      .draftSnapshotContent(contentRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Obtain a snapshot content.
   * @param {string} snapshotName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1ContentApi
   */
  public obtainSnapshotContent(snapshotName: string, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1ContentApiFp(this.configuration)
      .obtainSnapshotContent(snapshotName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Publish a snapshot content.
   * @param {string} snapshotName
   * @param {SubjectRef} subjectRef
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1ContentApi
   */
  public publishSnapshotContent(snapshotName: string, subjectRef: SubjectRef, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1ContentApiFp(this.configuration)
      .publishSnapshotContent(snapshotName, subjectRef, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update a snapshot content.
   * @param {string} snapshotName
   * @param {ContentRequest} contentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1ContentApi
   */
  public updateSnapshotContent(snapshotName: string, contentRequest: ContentRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1ContentApiFp(this.configuration)
      .updateSnapshotContent(snapshotName, contentRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installPlugin: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('installPlugin', 'file', file)
      const localVarPath = `/apis/api.halo.run/v1alpha1/plugins/install`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1PluginApiAxiosParamCreator(configuration)
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async installPlugin(
      file: any,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.installPlugin(file, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1PluginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1PluginApiFp(configuration)
  return {
    /**
     * Install a plugin by uploading a Jar file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installPlugin(file: any, options?: any): AxiosPromise<Plugin> {
      return localVarFp.installPlugin(file, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1PluginApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1PluginApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1PluginApi extends BaseAPI {
  /**
   * Install a plugin by uploading a Jar file.
   * @param {any} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1PluginApi
   */
  public installPlugin(file: any, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1PluginApiFp(this.configuration)
      .installPlugin(file, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1PostApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1PostApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Draft a post.
     * @param {PostRequest} postRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftPost: async (postRequest: PostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'postRequest' is not null or undefined
      assertParamExists('draftPost', 'postRequest', postRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(postRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List posts.
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {Set<string>} [contributors]
     * @param {Set<string>} [categories]
     * @param {Set<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPosts: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      contributors?: Set<string>,
      categories?: Set<string>,
      tags?: Set<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/api.halo.run/v1alpha1/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      if (contributors) {
        localVarQueryParameter['contributors'] = Array.from(contributors)
      }

      if (categories) {
        localVarQueryParameter['categories'] = Array.from(categories)
      }

      if (tags) {
        localVarQueryParameter['tags'] = Array.from(tags)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Publish a post.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishPost: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('publishPost', 'name', name)
      const localVarPath = `/apis/api.halo.run/v1alpha1/posts/{name}/publish`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update a post.
     * @param {string} name
     * @param {PostRequest} postRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftPost: async (
      name: string,
      postRequest: PostRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updateDraftPost', 'name', name)
      // verify required parameter 'postRequest' is not null or undefined
      assertParamExists('updateDraftPost', 'postRequest', postRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/posts/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(postRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1PostApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1PostApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1PostApiAxiosParamCreator(configuration)
  return {
    /**
     * Draft a post.
     * @param {PostRequest} postRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async draftPost(
      postRequest: PostRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.draftPost(postRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List posts.
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {Set<string>} [contributors]
     * @param {Set<string>} [categories]
     * @param {Set<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPosts(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      contributors?: Set<string>,
      categories?: Set<string>,
      tags?: Set<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedPostList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPosts(
        page,
        size,
        labelSelector,
        fieldSelector,
        contributors,
        categories,
        tags,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Publish a post.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async publishPost(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.publishPost(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update a post.
     * @param {string} name
     * @param {PostRequest} postRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDraftPost(
      name: string,
      postRequest: PostRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateDraftPost(name, postRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1PostApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1PostApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1PostApiFp(configuration)
  return {
    /**
     * Draft a post.
     * @param {PostRequest} postRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    draftPost(postRequest: PostRequest, options?: any): AxiosPromise<Post> {
      return localVarFp.draftPost(postRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * List posts.
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {Set<string>} [contributors]
     * @param {Set<string>} [categories]
     * @param {Set<string>} [tags]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPosts(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      contributors?: Set<string>,
      categories?: Set<string>,
      tags?: Set<string>,
      options?: any,
    ): AxiosPromise<ListedPostList> {
      return localVarFp
        .listPosts(page, size, labelSelector, fieldSelector, contributors, categories, tags, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Publish a post.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishPost(name: string, options?: any): AxiosPromise<Post> {
      return localVarFp.publishPost(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Update a post.
     * @param {string} name
     * @param {PostRequest} postRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDraftPost(name: string, postRequest: PostRequest, options?: any): AxiosPromise<Post> {
      return localVarFp.updateDraftPost(name, postRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1PostApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1PostApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1PostApi extends BaseAPI {
  /**
   * Draft a post.
   * @param {PostRequest} postRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1PostApi
   */
  public draftPost(postRequest: PostRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1PostApiFp(this.configuration)
      .draftPost(postRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List posts.
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {Set<string>} [contributors]
   * @param {Set<string>} [categories]
   * @param {Set<string>} [tags]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1PostApi
   */
  public listPosts(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    contributors?: Set<string>,
    categories?: Set<string>,
    tags?: Set<string>,
    options?: AxiosRequestConfig,
  ) {
    return ApiHaloRunV1alpha1PostApiFp(this.configuration)
      .listPosts(page, size, labelSelector, fieldSelector, contributors, categories, tags, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Publish a post.
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1PostApi
   */
  public publishPost(name: string, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1PostApiFp(this.configuration)
      .publishPost(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update a post.
   * @param {string} name
   * @param {PostRequest} postRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1PostApi
   */
  public updateDraftPost(name: string, postRequest: PostRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1PostApiFp(this.configuration)
      .updateDraftPost(name, postRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Install a theme by uploading a zip file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installTheme: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('installTheme', 'file', file)
      const localVarPath = `/apis/api.halo.run/v1alpha1/themes/install`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1ThemeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1ThemeApiAxiosParamCreator(configuration)
  return {
    /**
     * Install a theme by uploading a zip file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async installTheme(
      file: any,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.installTheme(file, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1ThemeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1ThemeApiFp(configuration)
  return {
    /**
     * Install a theme by uploading a zip file.
     * @param {any} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    installTheme(file: any, options?: any): AxiosPromise<Theme> {
      return localVarFp.installTheme(file, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1ThemeApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1ThemeApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1ThemeApi extends BaseAPI {
  /**
   * Install a theme by uploading a zip file.
   * @param {any} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1ThemeApi
   */
  public installTheme(file: any, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1ThemeApiFp(this.configuration)
      .installTheme(file, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - axios parameter creator
 * @export
 */
export const ApiHaloRunV1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      name: string,
      changePasswordRequest: ChangePasswordRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('changePassword', 'name', name)
      // verify required parameter 'changePasswordRequest' is not null or undefined
      assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/password`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/-`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getPermissions', 'name', name)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission: async (
      name: string,
      grantRequest: GrantRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('grantPermission', 'name', name)
      // verify required parameter 'grantRequest' is not null or undefined
      assertParamExists('grantPermission', 'grantRequest', grantRequest)
      const localVarPath = `/apis/api.halo.run/v1alpha1/users/{name}/permissions`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(grantRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - functional programming interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiHaloRunV1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      name: string,
      changePasswordRequest: ChangePasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(name, changePasswordRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCurrentUserDetail(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserDetail(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPermissions(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPermission>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPermissions(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grantPermission(
      name: string,
      grantRequest: GrantRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grantPermission(name, grantRequest, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - factory interface
 * @export
 */
export const ApiHaloRunV1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiHaloRunV1alpha1UserApiFp(configuration)
  return {
    /**
     * Change password of user.
     * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
     * @param {ChangePasswordRequest} changePasswordRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(name: string, changePasswordRequest: ChangePasswordRequest, options?: any): AxiosPromise<User> {
      return localVarFp.changePassword(name, changePasswordRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Get current user detail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUserDetail(options?: any): AxiosPromise<User> {
      return localVarFp.getCurrentUserDetail(options).then((request) => request(axios, basePath))
    },
    /**
     * Get permissions of user
     * @param {string} name User name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermissions(name: string, options?: any): AxiosPromise<UserPermission> {
      return localVarFp.getPermissions(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Grant permissions to user
     * @param {string} name User name
     * @param {GrantRequest} grantRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantPermission(name: string, grantRequest: GrantRequest, options?: any): AxiosPromise<User> {
      return localVarFp.grantPermission(name, grantRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ApiHaloRunV1alpha1UserApi - object-oriented interface
 * @export
 * @class ApiHaloRunV1alpha1UserApi
 * @extends {BaseAPI}
 */
export class ApiHaloRunV1alpha1UserApi extends BaseAPI {
  /**
   * Change password of user.
   * @param {string} name Name of user. If the name is equal to \&#39;-\&#39;, it will change the password of current user.
   * @param {ChangePasswordRequest} changePasswordRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public changePassword(name: string, changePasswordRequest: ChangePasswordRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .changePassword(name, changePasswordRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get current user detail
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getCurrentUserDetail(options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getCurrentUserDetail(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get permissions of user
   * @param {string} name User name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public getPermissions(name: string, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .getPermissions(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Grant permissions to user
   * @param {string} name User name
   * @param {GrantRequest} grantRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiHaloRunV1alpha1UserApi
   */
  public grantPermission(name: string, grantRequest: GrantRequest, options?: AxiosRequestConfig) {
    return ApiHaloRunV1alpha1UserApiFp(this.configuration)
      .grantPermission(name, grantRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContentHaloRunV1alpha1CategoryApi - axios parameter creator
 * @export
 */
export const ContentHaloRunV1alpha1CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create content.halo.run/v1alpha1/Category
     * @param {Category} [category] Fresh category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Category: async (
      category?: Category,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/categories`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Category: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecontentHaloRunV1alpha1Category', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/categories/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Category: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcontentHaloRunV1alpha1Category', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/categories/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List content.halo.run/v1alpha1/Category
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Category: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/categories`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {Category} [category] Updated category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Category: async (
      name: string,
      category?: Category,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecontentHaloRunV1alpha1Category', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/categories/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(category, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContentHaloRunV1alpha1CategoryApi - functional programming interface
 * @export
 */
export const ContentHaloRunV1alpha1CategoryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContentHaloRunV1alpha1CategoryApiAxiosParamCreator(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Category
     * @param {Category} [category] Fresh category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcontentHaloRunV1alpha1Category(
      category?: Category,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcontentHaloRunV1alpha1Category(category, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecontentHaloRunV1alpha1Category(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecontentHaloRunV1alpha1Category(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcontentHaloRunV1alpha1Category(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcontentHaloRunV1alpha1Category(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List content.halo.run/v1alpha1/Category
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcontentHaloRunV1alpha1Category(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcontentHaloRunV1alpha1Category(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {Category} [category] Updated category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecontentHaloRunV1alpha1Category(
      name: string,
      category?: Category,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecontentHaloRunV1alpha1Category(
        name,
        category,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ContentHaloRunV1alpha1CategoryApi - factory interface
 * @export
 */
export const ContentHaloRunV1alpha1CategoryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContentHaloRunV1alpha1CategoryApiFp(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Category
     * @param {Category} [category] Fresh category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Category(category?: Category, options?: any): AxiosPromise<Category> {
      return localVarFp
        .createcontentHaloRunV1alpha1Category(category, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Category(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecontentHaloRunV1alpha1Category(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Category(name: string, options?: any): AxiosPromise<Category> {
      return localVarFp.getcontentHaloRunV1alpha1Category(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List content.halo.run/v1alpha1/Category
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Category(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<CategoryList> {
      return localVarFp
        .listcontentHaloRunV1alpha1Category(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update content.halo.run/v1alpha1/Category
     * @param {string} name Name of category
     * @param {Category} [category] Updated category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Category(name: string, category?: Category, options?: any): AxiosPromise<Category> {
      return localVarFp
        .updatecontentHaloRunV1alpha1Category(name, category, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContentHaloRunV1alpha1CategoryApi - object-oriented interface
 * @export
 * @class ContentHaloRunV1alpha1CategoryApi
 * @extends {BaseAPI}
 */
export class ContentHaloRunV1alpha1CategoryApi extends BaseAPI {
  /**
   * Create content.halo.run/v1alpha1/Category
   * @param {Category} [category] Fresh category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CategoryApi
   */
  public createcontentHaloRunV1alpha1Category(category?: Category, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CategoryApiFp(this.configuration)
      .createcontentHaloRunV1alpha1Category(category, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete content.halo.run/v1alpha1/Category
   * @param {string} name Name of category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CategoryApi
   */
  public deletecontentHaloRunV1alpha1Category(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CategoryApiFp(this.configuration)
      .deletecontentHaloRunV1alpha1Category(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get content.halo.run/v1alpha1/Category
   * @param {string} name Name of category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CategoryApi
   */
  public getcontentHaloRunV1alpha1Category(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CategoryApiFp(this.configuration)
      .getcontentHaloRunV1alpha1Category(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List content.halo.run/v1alpha1/Category
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CategoryApi
   */
  public listcontentHaloRunV1alpha1Category(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ContentHaloRunV1alpha1CategoryApiFp(this.configuration)
      .listcontentHaloRunV1alpha1Category(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update content.halo.run/v1alpha1/Category
   * @param {string} name Name of category
   * @param {Category} [category] Updated category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CategoryApi
   */
  public updatecontentHaloRunV1alpha1Category(name: string, category?: Category, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CategoryApiFp(this.configuration)
      .updatecontentHaloRunV1alpha1Category(name, category, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContentHaloRunV1alpha1CommentApi - axios parameter creator
 * @export
 */
export const ContentHaloRunV1alpha1CommentApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create content.halo.run/v1alpha1/Comment
     * @param {Comment} [comment] Fresh comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Comment: async (
      comment?: Comment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/comments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Comment: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecontentHaloRunV1alpha1Comment', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/comments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Comment: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcontentHaloRunV1alpha1Comment', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/comments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List content.halo.run/v1alpha1/Comment
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Comment: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/comments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {Comment} [comment] Updated comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Comment: async (
      name: string,
      comment?: Comment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecontentHaloRunV1alpha1Comment', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/comments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContentHaloRunV1alpha1CommentApi - functional programming interface
 * @export
 */
export const ContentHaloRunV1alpha1CommentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContentHaloRunV1alpha1CommentApiAxiosParamCreator(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Comment
     * @param {Comment} [comment] Fresh comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcontentHaloRunV1alpha1Comment(
      comment?: Comment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcontentHaloRunV1alpha1Comment(comment, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecontentHaloRunV1alpha1Comment(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecontentHaloRunV1alpha1Comment(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcontentHaloRunV1alpha1Comment(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcontentHaloRunV1alpha1Comment(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List content.halo.run/v1alpha1/Comment
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcontentHaloRunV1alpha1Comment(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcontentHaloRunV1alpha1Comment(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {Comment} [comment] Updated comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecontentHaloRunV1alpha1Comment(
      name: string,
      comment?: Comment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecontentHaloRunV1alpha1Comment(
        name,
        comment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ContentHaloRunV1alpha1CommentApi - factory interface
 * @export
 */
export const ContentHaloRunV1alpha1CommentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContentHaloRunV1alpha1CommentApiFp(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Comment
     * @param {Comment} [comment] Fresh comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Comment(comment?: Comment, options?: any): AxiosPromise<Comment> {
      return localVarFp
        .createcontentHaloRunV1alpha1Comment(comment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Comment(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecontentHaloRunV1alpha1Comment(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Comment(name: string, options?: any): AxiosPromise<Comment> {
      return localVarFp.getcontentHaloRunV1alpha1Comment(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List content.halo.run/v1alpha1/Comment
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Comment(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<CommentList> {
      return localVarFp
        .listcontentHaloRunV1alpha1Comment(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update content.halo.run/v1alpha1/Comment
     * @param {string} name Name of comment
     * @param {Comment} [comment] Updated comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Comment(name: string, comment?: Comment, options?: any): AxiosPromise<Comment> {
      return localVarFp
        .updatecontentHaloRunV1alpha1Comment(name, comment, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContentHaloRunV1alpha1CommentApi - object-oriented interface
 * @export
 * @class ContentHaloRunV1alpha1CommentApi
 * @extends {BaseAPI}
 */
export class ContentHaloRunV1alpha1CommentApi extends BaseAPI {
  /**
   * Create content.halo.run/v1alpha1/Comment
   * @param {Comment} [comment] Fresh comment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CommentApi
   */
  public createcontentHaloRunV1alpha1Comment(comment?: Comment, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CommentApiFp(this.configuration)
      .createcontentHaloRunV1alpha1Comment(comment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete content.halo.run/v1alpha1/Comment
   * @param {string} name Name of comment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CommentApi
   */
  public deletecontentHaloRunV1alpha1Comment(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CommentApiFp(this.configuration)
      .deletecontentHaloRunV1alpha1Comment(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get content.halo.run/v1alpha1/Comment
   * @param {string} name Name of comment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CommentApi
   */
  public getcontentHaloRunV1alpha1Comment(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CommentApiFp(this.configuration)
      .getcontentHaloRunV1alpha1Comment(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List content.halo.run/v1alpha1/Comment
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CommentApi
   */
  public listcontentHaloRunV1alpha1Comment(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ContentHaloRunV1alpha1CommentApiFp(this.configuration)
      .listcontentHaloRunV1alpha1Comment(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update content.halo.run/v1alpha1/Comment
   * @param {string} name Name of comment
   * @param {Comment} [comment] Updated comment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1CommentApi
   */
  public updatecontentHaloRunV1alpha1Comment(name: string, comment?: Comment, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1CommentApiFp(this.configuration)
      .updatecontentHaloRunV1alpha1Comment(name, comment, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContentHaloRunV1alpha1PostApi - axios parameter creator
 * @export
 */
export const ContentHaloRunV1alpha1PostApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create content.halo.run/v1alpha1/Post
     * @param {Post} [post] Fresh post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Post: async (post?: Post, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Post: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecontentHaloRunV1alpha1Post', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/posts/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Post: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcontentHaloRunV1alpha1Post', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/posts/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List content.halo.run/v1alpha1/Post
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Post: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/posts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {Post} [post] Updated post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Post: async (
      name: string,
      post?: Post,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecontentHaloRunV1alpha1Post', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/posts/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(post, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContentHaloRunV1alpha1PostApi - functional programming interface
 * @export
 */
export const ContentHaloRunV1alpha1PostApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContentHaloRunV1alpha1PostApiAxiosParamCreator(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Post
     * @param {Post} [post] Fresh post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcontentHaloRunV1alpha1Post(
      post?: Post,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcontentHaloRunV1alpha1Post(post, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecontentHaloRunV1alpha1Post(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecontentHaloRunV1alpha1Post(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcontentHaloRunV1alpha1Post(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcontentHaloRunV1alpha1Post(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List content.halo.run/v1alpha1/Post
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcontentHaloRunV1alpha1Post(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcontentHaloRunV1alpha1Post(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {Post} [post] Updated post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecontentHaloRunV1alpha1Post(
      name: string,
      post?: Post,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Post>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecontentHaloRunV1alpha1Post(name, post, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ContentHaloRunV1alpha1PostApi - factory interface
 * @export
 */
export const ContentHaloRunV1alpha1PostApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContentHaloRunV1alpha1PostApiFp(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Post
     * @param {Post} [post] Fresh post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Post(post?: Post, options?: any): AxiosPromise<Post> {
      return localVarFp.createcontentHaloRunV1alpha1Post(post, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Post(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecontentHaloRunV1alpha1Post(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Post(name: string, options?: any): AxiosPromise<Post> {
      return localVarFp.getcontentHaloRunV1alpha1Post(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List content.halo.run/v1alpha1/Post
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Post(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<PostList> {
      return localVarFp
        .listcontentHaloRunV1alpha1Post(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update content.halo.run/v1alpha1/Post
     * @param {string} name Name of post
     * @param {Post} [post] Updated post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Post(name: string, post?: Post, options?: any): AxiosPromise<Post> {
      return localVarFp
        .updatecontentHaloRunV1alpha1Post(name, post, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContentHaloRunV1alpha1PostApi - object-oriented interface
 * @export
 * @class ContentHaloRunV1alpha1PostApi
 * @extends {BaseAPI}
 */
export class ContentHaloRunV1alpha1PostApi extends BaseAPI {
  /**
   * Create content.halo.run/v1alpha1/Post
   * @param {Post} [post] Fresh post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1PostApi
   */
  public createcontentHaloRunV1alpha1Post(post?: Post, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1PostApiFp(this.configuration)
      .createcontentHaloRunV1alpha1Post(post, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete content.halo.run/v1alpha1/Post
   * @param {string} name Name of post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1PostApi
   */
  public deletecontentHaloRunV1alpha1Post(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1PostApiFp(this.configuration)
      .deletecontentHaloRunV1alpha1Post(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get content.halo.run/v1alpha1/Post
   * @param {string} name Name of post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1PostApi
   */
  public getcontentHaloRunV1alpha1Post(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1PostApiFp(this.configuration)
      .getcontentHaloRunV1alpha1Post(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List content.halo.run/v1alpha1/Post
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1PostApi
   */
  public listcontentHaloRunV1alpha1Post(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ContentHaloRunV1alpha1PostApiFp(this.configuration)
      .listcontentHaloRunV1alpha1Post(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update content.halo.run/v1alpha1/Post
   * @param {string} name Name of post
   * @param {Post} [post] Updated post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1PostApi
   */
  public updatecontentHaloRunV1alpha1Post(name: string, post?: Post, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1PostApiFp(this.configuration)
      .updatecontentHaloRunV1alpha1Post(name, post, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContentHaloRunV1alpha1ReplyApi - axios parameter creator
 * @export
 */
export const ContentHaloRunV1alpha1ReplyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create content.halo.run/v1alpha1/Reply
     * @param {Reply} [reply] Fresh reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Reply: async (
      reply?: Reply,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/replies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reply, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Reply: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecontentHaloRunV1alpha1Reply', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/replies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Reply: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcontentHaloRunV1alpha1Reply', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/replies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List content.halo.run/v1alpha1/Reply
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Reply: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/replies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {Reply} [reply] Updated reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Reply: async (
      name: string,
      reply?: Reply,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecontentHaloRunV1alpha1Reply', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/replies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reply, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContentHaloRunV1alpha1ReplyApi - functional programming interface
 * @export
 */
export const ContentHaloRunV1alpha1ReplyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContentHaloRunV1alpha1ReplyApiAxiosParamCreator(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Reply
     * @param {Reply} [reply] Fresh reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcontentHaloRunV1alpha1Reply(
      reply?: Reply,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reply>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcontentHaloRunV1alpha1Reply(reply, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecontentHaloRunV1alpha1Reply(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecontentHaloRunV1alpha1Reply(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcontentHaloRunV1alpha1Reply(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reply>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcontentHaloRunV1alpha1Reply(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List content.halo.run/v1alpha1/Reply
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcontentHaloRunV1alpha1Reply(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReplyList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcontentHaloRunV1alpha1Reply(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {Reply} [reply] Updated reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecontentHaloRunV1alpha1Reply(
      name: string,
      reply?: Reply,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reply>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecontentHaloRunV1alpha1Reply(name, reply, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ContentHaloRunV1alpha1ReplyApi - factory interface
 * @export
 */
export const ContentHaloRunV1alpha1ReplyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContentHaloRunV1alpha1ReplyApiFp(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Reply
     * @param {Reply} [reply] Fresh reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Reply(reply?: Reply, options?: any): AxiosPromise<Reply> {
      return localVarFp.createcontentHaloRunV1alpha1Reply(reply, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Reply(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecontentHaloRunV1alpha1Reply(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Reply(name: string, options?: any): AxiosPromise<Reply> {
      return localVarFp.getcontentHaloRunV1alpha1Reply(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List content.halo.run/v1alpha1/Reply
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Reply(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<ReplyList> {
      return localVarFp
        .listcontentHaloRunV1alpha1Reply(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update content.halo.run/v1alpha1/Reply
     * @param {string} name Name of reply
     * @param {Reply} [reply] Updated reply
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Reply(name: string, reply?: Reply, options?: any): AxiosPromise<Reply> {
      return localVarFp
        .updatecontentHaloRunV1alpha1Reply(name, reply, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContentHaloRunV1alpha1ReplyApi - object-oriented interface
 * @export
 * @class ContentHaloRunV1alpha1ReplyApi
 * @extends {BaseAPI}
 */
export class ContentHaloRunV1alpha1ReplyApi extends BaseAPI {
  /**
   * Create content.halo.run/v1alpha1/Reply
   * @param {Reply} [reply] Fresh reply
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1ReplyApi
   */
  public createcontentHaloRunV1alpha1Reply(reply?: Reply, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1ReplyApiFp(this.configuration)
      .createcontentHaloRunV1alpha1Reply(reply, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete content.halo.run/v1alpha1/Reply
   * @param {string} name Name of reply
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1ReplyApi
   */
  public deletecontentHaloRunV1alpha1Reply(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1ReplyApiFp(this.configuration)
      .deletecontentHaloRunV1alpha1Reply(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get content.halo.run/v1alpha1/Reply
   * @param {string} name Name of reply
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1ReplyApi
   */
  public getcontentHaloRunV1alpha1Reply(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1ReplyApiFp(this.configuration)
      .getcontentHaloRunV1alpha1Reply(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List content.halo.run/v1alpha1/Reply
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1ReplyApi
   */
  public listcontentHaloRunV1alpha1Reply(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ContentHaloRunV1alpha1ReplyApiFp(this.configuration)
      .listcontentHaloRunV1alpha1Reply(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update content.halo.run/v1alpha1/Reply
   * @param {string} name Name of reply
   * @param {Reply} [reply] Updated reply
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1ReplyApi
   */
  public updatecontentHaloRunV1alpha1Reply(name: string, reply?: Reply, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1ReplyApiFp(this.configuration)
      .updatecontentHaloRunV1alpha1Reply(name, reply, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContentHaloRunV1alpha1SnapshotApi - axios parameter creator
 * @export
 */
export const ContentHaloRunV1alpha1SnapshotApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create content.halo.run/v1alpha1/Snapshot
     * @param {Snapshot} [snapshot] Fresh snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Snapshot: async (
      snapshot?: Snapshot,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/snapshots`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(snapshot, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Snapshot: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecontentHaloRunV1alpha1Snapshot', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/snapshots/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Snapshot: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcontentHaloRunV1alpha1Snapshot', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/snapshots/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List content.halo.run/v1alpha1/Snapshot
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Snapshot: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/snapshots`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {Snapshot} [snapshot] Updated snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Snapshot: async (
      name: string,
      snapshot?: Snapshot,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecontentHaloRunV1alpha1Snapshot', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/snapshots/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(snapshot, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContentHaloRunV1alpha1SnapshotApi - functional programming interface
 * @export
 */
export const ContentHaloRunV1alpha1SnapshotApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContentHaloRunV1alpha1SnapshotApiAxiosParamCreator(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Snapshot
     * @param {Snapshot} [snapshot] Fresh snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcontentHaloRunV1alpha1Snapshot(
      snapshot?: Snapshot,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snapshot>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcontentHaloRunV1alpha1Snapshot(snapshot, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecontentHaloRunV1alpha1Snapshot(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecontentHaloRunV1alpha1Snapshot(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcontentHaloRunV1alpha1Snapshot(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snapshot>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcontentHaloRunV1alpha1Snapshot(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List content.halo.run/v1alpha1/Snapshot
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcontentHaloRunV1alpha1Snapshot(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapshotList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcontentHaloRunV1alpha1Snapshot(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {Snapshot} [snapshot] Updated snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecontentHaloRunV1alpha1Snapshot(
      name: string,
      snapshot?: Snapshot,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Snapshot>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecontentHaloRunV1alpha1Snapshot(
        name,
        snapshot,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ContentHaloRunV1alpha1SnapshotApi - factory interface
 * @export
 */
export const ContentHaloRunV1alpha1SnapshotApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContentHaloRunV1alpha1SnapshotApiFp(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Snapshot
     * @param {Snapshot} [snapshot] Fresh snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Snapshot(snapshot?: Snapshot, options?: any): AxiosPromise<Snapshot> {
      return localVarFp
        .createcontentHaloRunV1alpha1Snapshot(snapshot, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Snapshot(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecontentHaloRunV1alpha1Snapshot(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Snapshot(name: string, options?: any): AxiosPromise<Snapshot> {
      return localVarFp.getcontentHaloRunV1alpha1Snapshot(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List content.halo.run/v1alpha1/Snapshot
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Snapshot(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<SnapshotList> {
      return localVarFp
        .listcontentHaloRunV1alpha1Snapshot(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update content.halo.run/v1alpha1/Snapshot
     * @param {string} name Name of snapshot
     * @param {Snapshot} [snapshot] Updated snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Snapshot(name: string, snapshot?: Snapshot, options?: any): AxiosPromise<Snapshot> {
      return localVarFp
        .updatecontentHaloRunV1alpha1Snapshot(name, snapshot, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContentHaloRunV1alpha1SnapshotApi - object-oriented interface
 * @export
 * @class ContentHaloRunV1alpha1SnapshotApi
 * @extends {BaseAPI}
 */
export class ContentHaloRunV1alpha1SnapshotApi extends BaseAPI {
  /**
   * Create content.halo.run/v1alpha1/Snapshot
   * @param {Snapshot} [snapshot] Fresh snapshot
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1SnapshotApi
   */
  public createcontentHaloRunV1alpha1Snapshot(snapshot?: Snapshot, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1SnapshotApiFp(this.configuration)
      .createcontentHaloRunV1alpha1Snapshot(snapshot, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete content.halo.run/v1alpha1/Snapshot
   * @param {string} name Name of snapshot
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1SnapshotApi
   */
  public deletecontentHaloRunV1alpha1Snapshot(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1SnapshotApiFp(this.configuration)
      .deletecontentHaloRunV1alpha1Snapshot(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get content.halo.run/v1alpha1/Snapshot
   * @param {string} name Name of snapshot
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1SnapshotApi
   */
  public getcontentHaloRunV1alpha1Snapshot(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1SnapshotApiFp(this.configuration)
      .getcontentHaloRunV1alpha1Snapshot(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List content.halo.run/v1alpha1/Snapshot
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1SnapshotApi
   */
  public listcontentHaloRunV1alpha1Snapshot(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ContentHaloRunV1alpha1SnapshotApiFp(this.configuration)
      .listcontentHaloRunV1alpha1Snapshot(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update content.halo.run/v1alpha1/Snapshot
   * @param {string} name Name of snapshot
   * @param {Snapshot} [snapshot] Updated snapshot
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1SnapshotApi
   */
  public updatecontentHaloRunV1alpha1Snapshot(name: string, snapshot?: Snapshot, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1SnapshotApiFp(this.configuration)
      .updatecontentHaloRunV1alpha1Snapshot(name, snapshot, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContentHaloRunV1alpha1TagApi - axios parameter creator
 * @export
 */
export const ContentHaloRunV1alpha1TagApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create content.halo.run/v1alpha1/Tag
     * @param {Tag} [tag] Fresh tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Tag: async (tag?: Tag, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/tags`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Tag: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletecontentHaloRunV1alpha1Tag', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/tags/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Tag: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getcontentHaloRunV1alpha1Tag', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/tags/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List content.halo.run/v1alpha1/Tag
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Tag: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/content.halo.run/v1alpha1/tags`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {Tag} [tag] Updated tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Tag: async (
      name: string,
      tag?: Tag,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatecontentHaloRunV1alpha1Tag', 'name', name)
      const localVarPath = `/apis/content.halo.run/v1alpha1/tags/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContentHaloRunV1alpha1TagApi - functional programming interface
 * @export
 */
export const ContentHaloRunV1alpha1TagApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContentHaloRunV1alpha1TagApiAxiosParamCreator(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Tag
     * @param {Tag} [tag] Fresh tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createcontentHaloRunV1alpha1Tag(
      tag?: Tag,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createcontentHaloRunV1alpha1Tag(tag, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletecontentHaloRunV1alpha1Tag(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletecontentHaloRunV1alpha1Tag(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getcontentHaloRunV1alpha1Tag(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getcontentHaloRunV1alpha1Tag(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List content.halo.run/v1alpha1/Tag
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listcontentHaloRunV1alpha1Tag(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listcontentHaloRunV1alpha1Tag(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {Tag} [tag] Updated tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatecontentHaloRunV1alpha1Tag(
      name: string,
      tag?: Tag,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatecontentHaloRunV1alpha1Tag(name, tag, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ContentHaloRunV1alpha1TagApi - factory interface
 * @export
 */
export const ContentHaloRunV1alpha1TagApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ContentHaloRunV1alpha1TagApiFp(configuration)
  return {
    /**
     * Create content.halo.run/v1alpha1/Tag
     * @param {Tag} [tag] Fresh tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createcontentHaloRunV1alpha1Tag(tag?: Tag, options?: any): AxiosPromise<Tag> {
      return localVarFp.createcontentHaloRunV1alpha1Tag(tag, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletecontentHaloRunV1alpha1Tag(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletecontentHaloRunV1alpha1Tag(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getcontentHaloRunV1alpha1Tag(name: string, options?: any): AxiosPromise<Tag> {
      return localVarFp.getcontentHaloRunV1alpha1Tag(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List content.halo.run/v1alpha1/Tag
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listcontentHaloRunV1alpha1Tag(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<TagList> {
      return localVarFp
        .listcontentHaloRunV1alpha1Tag(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update content.halo.run/v1alpha1/Tag
     * @param {string} name Name of tag
     * @param {Tag} [tag] Updated tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatecontentHaloRunV1alpha1Tag(name: string, tag?: Tag, options?: any): AxiosPromise<Tag> {
      return localVarFp.updatecontentHaloRunV1alpha1Tag(name, tag, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContentHaloRunV1alpha1TagApi - object-oriented interface
 * @export
 * @class ContentHaloRunV1alpha1TagApi
 * @extends {BaseAPI}
 */
export class ContentHaloRunV1alpha1TagApi extends BaseAPI {
  /**
   * Create content.halo.run/v1alpha1/Tag
   * @param {Tag} [tag] Fresh tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1TagApi
   */
  public createcontentHaloRunV1alpha1Tag(tag?: Tag, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1TagApiFp(this.configuration)
      .createcontentHaloRunV1alpha1Tag(tag, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete content.halo.run/v1alpha1/Tag
   * @param {string} name Name of tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1TagApi
   */
  public deletecontentHaloRunV1alpha1Tag(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1TagApiFp(this.configuration)
      .deletecontentHaloRunV1alpha1Tag(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get content.halo.run/v1alpha1/Tag
   * @param {string} name Name of tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1TagApi
   */
  public getcontentHaloRunV1alpha1Tag(name: string, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1TagApiFp(this.configuration)
      .getcontentHaloRunV1alpha1Tag(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List content.halo.run/v1alpha1/Tag
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1TagApi
   */
  public listcontentHaloRunV1alpha1Tag(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ContentHaloRunV1alpha1TagApiFp(this.configuration)
      .listcontentHaloRunV1alpha1Tag(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update content.halo.run/v1alpha1/Tag
   * @param {string} name Name of tag
   * @param {Tag} [tag] Updated tag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentHaloRunV1alpha1TagApi
   */
  public updatecontentHaloRunV1alpha1Tag(name: string, tag?: Tag, options?: AxiosRequestConfig) {
    return ContentHaloRunV1alpha1TagApiFp(this.configuration)
      .updatecontentHaloRunV1alpha1Tag(name, tag, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin: async (
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin: async (
      name: string,
      plugin?: Plugin,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1Plugin', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/plugins/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(plugin, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1PluginApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1Plugin(
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1Plugin(plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1Plugin(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1Plugin(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1Plugin(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1Plugin(
      name: string,
      plugin?: Plugin,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugin>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1PluginApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1PluginApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/Plugin
     * @param {Plugin} [plugin] Fresh plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp.createpluginHaloRunV1alpha1Plugin(plugin, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletepluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1Plugin(name: string, options?: any): AxiosPromise<Plugin> {
      return localVarFp.getpluginHaloRunV1alpha1Plugin(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/Plugin
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1Plugin(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<PluginList> {
      return localVarFp
        .listpluginHaloRunV1alpha1Plugin(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/Plugin
     * @param {string} name Name of plugin
     * @param {Plugin} [plugin] Updated plugin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: any): AxiosPromise<Plugin> {
      return localVarFp
        .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1PluginApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1PluginApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1PluginApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/Plugin
   * @param {Plugin} [plugin] Fresh plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public createpluginHaloRunV1alpha1Plugin(plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .createpluginHaloRunV1alpha1Plugin(plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public deletepluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public getpluginHaloRunV1alpha1Plugin(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .getpluginHaloRunV1alpha1Plugin(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/Plugin
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public listpluginHaloRunV1alpha1Plugin(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .listpluginHaloRunV1alpha1Plugin(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/Plugin
   * @param {string} name Name of plugin
   * @param {Plugin} [plugin] Updated plugin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1PluginApi
   */
  public updatepluginHaloRunV1alpha1Plugin(name: string, plugin?: Plugin, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1PluginApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1Plugin(name, plugin, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - axios parameter creator
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy: async (
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getpluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy: async (
      name: string,
      reverseProxy?: ReverseProxy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatepluginHaloRunV1alpha1ReverseProxy', 'name', name)
      const localVarPath = `/apis/plugin.halo.run/v1alpha1/reverseproxies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(reverseProxy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - functional programming interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PluginHaloRunV1alpha1ReverseProxyApiAxiosParamCreator(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createpluginHaloRunV1alpha1ReverseProxy(
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createpluginHaloRunV1alpha1ReverseProxy(
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getpluginHaloRunV1alpha1ReverseProxy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getpluginHaloRunV1alpha1ReverseProxy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxyList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listpluginHaloRunV1alpha1ReverseProxy(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReverseProxy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatepluginHaloRunV1alpha1ReverseProxy(
        name,
        reverseProxy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - factory interface
 * @export
 */
export const PluginHaloRunV1alpha1ReverseProxyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PluginHaloRunV1alpha1ReverseProxyApiFp(configuration)
  return {
    /**
     * Create plugin.halo.run/v1alpha1/ReverseProxy
     * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp
        .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: any): AxiosPromise<ReverseProxy> {
      return localVarFp.getpluginHaloRunV1alpha1ReverseProxy(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List plugin.halo.run/v1alpha1/ReverseProxy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listpluginHaloRunV1alpha1ReverseProxy(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<ReverseProxyList> {
      return localVarFp
        .listpluginHaloRunV1alpha1ReverseProxy(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update plugin.halo.run/v1alpha1/ReverseProxy
     * @param {string} name Name of reverseproxy
     * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatepluginHaloRunV1alpha1ReverseProxy(
      name: string,
      reverseProxy?: ReverseProxy,
      options?: any,
    ): AxiosPromise<ReverseProxy> {
      return localVarFp
        .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PluginHaloRunV1alpha1ReverseProxyApi - object-oriented interface
 * @export
 * @class PluginHaloRunV1alpha1ReverseProxyApi
 * @extends {BaseAPI}
 */
export class PluginHaloRunV1alpha1ReverseProxyApi extends BaseAPI {
  /**
   * Create plugin.halo.run/v1alpha1/ReverseProxy
   * @param {ReverseProxy} [reverseProxy] Fresh reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public createpluginHaloRunV1alpha1ReverseProxy(reverseProxy?: ReverseProxy, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .createpluginHaloRunV1alpha1ReverseProxy(reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public deletepluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .deletepluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public getpluginHaloRunV1alpha1ReverseProxy(name: string, options?: AxiosRequestConfig) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .getpluginHaloRunV1alpha1ReverseProxy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List plugin.halo.run/v1alpha1/ReverseProxy
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public listpluginHaloRunV1alpha1ReverseProxy(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .listpluginHaloRunV1alpha1ReverseProxy(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update plugin.halo.run/v1alpha1/ReverseProxy
   * @param {string} name Name of reverseproxy
   * @param {ReverseProxy} [reverseProxy] Updated reverseproxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PluginHaloRunV1alpha1ReverseProxyApi
   */
  public updatepluginHaloRunV1alpha1ReverseProxy(
    name: string,
    reverseProxy?: ReverseProxy,
    options?: AxiosRequestConfig,
  ) {
    return PluginHaloRunV1alpha1ReverseProxyApiFp(this.configuration)
      .updatepluginHaloRunV1alpha1ReverseProxy(name, reverseProxy, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StorageHaloRunV1alpha1AttachmentApi - axios parameter creator
 * @export
 */
export const StorageHaloRunV1alpha1AttachmentApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create storage.halo.run/v1alpha1/Attachment
     * @param {Attachment} [attachment] Fresh attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1Attachment: async (
      attachment?: Attachment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/attachments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(attachment, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1Attachment: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletestorageHaloRunV1alpha1Attachment', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/attachments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1Attachment: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getstorageHaloRunV1alpha1Attachment', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/attachments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List storage.halo.run/v1alpha1/Attachment
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1Attachment: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/attachments`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {Attachment} [attachment] Updated attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1Attachment: async (
      name: string,
      attachment?: Attachment,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatestorageHaloRunV1alpha1Attachment', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/attachments/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(attachment, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {any} file
     * @param {string} policyName Storage policy name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment: async (file: any, policyName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('uploadAttachment', 'file', file)
      // verify required parameter 'policyName' is not null or undefined
      assertParamExists('uploadAttachment', 'policyName', policyName)
      const localVarPath = `/apis/api.halo.run/v1alpha1/attachments/upload`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      if (policyName !== undefined) {
        localVarFormParams.append('policyName', policyName as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StorageHaloRunV1alpha1AttachmentApi - functional programming interface
 * @export
 */
export const StorageHaloRunV1alpha1AttachmentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StorageHaloRunV1alpha1AttachmentApiAxiosParamCreator(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/Attachment
     * @param {Attachment} [attachment] Fresh attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createstorageHaloRunV1alpha1Attachment(
      attachment?: Attachment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createstorageHaloRunV1alpha1Attachment(
        attachment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletestorageHaloRunV1alpha1Attachment(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletestorageHaloRunV1alpha1Attachment(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getstorageHaloRunV1alpha1Attachment(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getstorageHaloRunV1alpha1Attachment(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List storage.halo.run/v1alpha1/Attachment
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async liststorageHaloRunV1alpha1Attachment(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.liststorageHaloRunV1alpha1Attachment(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {Attachment} [attachment] Updated attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatestorageHaloRunV1alpha1Attachment(
      name: string,
      attachment?: Attachment,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatestorageHaloRunV1alpha1Attachment(
        name,
        attachment,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {any} file
     * @param {string} policyName Storage policy name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadAttachment(
      file: any,
      policyName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAttachment(file, policyName, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * StorageHaloRunV1alpha1AttachmentApi - factory interface
 * @export
 */
export const StorageHaloRunV1alpha1AttachmentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StorageHaloRunV1alpha1AttachmentApiFp(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/Attachment
     * @param {Attachment} [attachment] Fresh attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1Attachment(attachment?: Attachment, options?: any): AxiosPromise<Attachment> {
      return localVarFp
        .createstorageHaloRunV1alpha1Attachment(attachment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1Attachment(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletestorageHaloRunV1alpha1Attachment(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1Attachment(name: string, options?: any): AxiosPromise<Attachment> {
      return localVarFp.getstorageHaloRunV1alpha1Attachment(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List storage.halo.run/v1alpha1/Attachment
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1Attachment(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<AttachmentList> {
      return localVarFp
        .liststorageHaloRunV1alpha1Attachment(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update storage.halo.run/v1alpha1/Attachment
     * @param {string} name Name of attachment
     * @param {Attachment} [attachment] Updated attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1Attachment(
      name: string,
      attachment?: Attachment,
      options?: any,
    ): AxiosPromise<Attachment> {
      return localVarFp
        .updatestorageHaloRunV1alpha1Attachment(name, attachment, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {any} file
     * @param {string} policyName Storage policy name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadAttachment(file: any, policyName: string, options?: any): AxiosPromise<Attachment> {
      return localVarFp.uploadAttachment(file, policyName, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * StorageHaloRunV1alpha1AttachmentApi - object-oriented interface
 * @export
 * @class StorageHaloRunV1alpha1AttachmentApi
 * @extends {BaseAPI}
 */
export class StorageHaloRunV1alpha1AttachmentApi extends BaseAPI {
  /**
   * Create storage.halo.run/v1alpha1/Attachment
   * @param {Attachment} [attachment] Fresh attachment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1AttachmentApi
   */
  public createstorageHaloRunV1alpha1Attachment(attachment?: Attachment, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1AttachmentApiFp(this.configuration)
      .createstorageHaloRunV1alpha1Attachment(attachment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete storage.halo.run/v1alpha1/Attachment
   * @param {string} name Name of attachment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1AttachmentApi
   */
  public deletestorageHaloRunV1alpha1Attachment(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1AttachmentApiFp(this.configuration)
      .deletestorageHaloRunV1alpha1Attachment(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get storage.halo.run/v1alpha1/Attachment
   * @param {string} name Name of attachment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1AttachmentApi
   */
  public getstorageHaloRunV1alpha1Attachment(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1AttachmentApiFp(this.configuration)
      .getstorageHaloRunV1alpha1Attachment(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List storage.halo.run/v1alpha1/Attachment
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1AttachmentApi
   */
  public liststorageHaloRunV1alpha1Attachment(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return StorageHaloRunV1alpha1AttachmentApiFp(this.configuration)
      .liststorageHaloRunV1alpha1Attachment(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update storage.halo.run/v1alpha1/Attachment
   * @param {string} name Name of attachment
   * @param {Attachment} [attachment] Updated attachment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1AttachmentApi
   */
  public updatestorageHaloRunV1alpha1Attachment(name: string, attachment?: Attachment, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1AttachmentApiFp(this.configuration)
      .updatestorageHaloRunV1alpha1Attachment(name, attachment, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {any} file
   * @param {string} policyName Storage policy name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1AttachmentApi
   */
  public uploadAttachment(file: any, policyName: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1AttachmentApiFp(this.configuration)
      .uploadAttachment(file, policyName, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StorageHaloRunV1alpha1GroupApi - axios parameter creator
 * @export
 */
export const StorageHaloRunV1alpha1GroupApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create storage.halo.run/v1alpha1/Group
     * @param {Group} [group] Fresh group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1Group: async (
      group?: Group,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1Group: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletestorageHaloRunV1alpha1Group', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/groups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1Group: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getstorageHaloRunV1alpha1Group', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/groups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List storage.halo.run/v1alpha1/Group
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1Group: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {Group} [group] Updated group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1Group: async (
      name: string,
      group?: Group,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatestorageHaloRunV1alpha1Group', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/groups/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StorageHaloRunV1alpha1GroupApi - functional programming interface
 * @export
 */
export const StorageHaloRunV1alpha1GroupApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StorageHaloRunV1alpha1GroupApiAxiosParamCreator(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/Group
     * @param {Group} [group] Fresh group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createstorageHaloRunV1alpha1Group(
      group?: Group,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createstorageHaloRunV1alpha1Group(group, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletestorageHaloRunV1alpha1Group(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletestorageHaloRunV1alpha1Group(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getstorageHaloRunV1alpha1Group(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getstorageHaloRunV1alpha1Group(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List storage.halo.run/v1alpha1/Group
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async liststorageHaloRunV1alpha1Group(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.liststorageHaloRunV1alpha1Group(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {Group} [group] Updated group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatestorageHaloRunV1alpha1Group(
      name: string,
      group?: Group,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatestorageHaloRunV1alpha1Group(name, group, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * StorageHaloRunV1alpha1GroupApi - factory interface
 * @export
 */
export const StorageHaloRunV1alpha1GroupApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StorageHaloRunV1alpha1GroupApiFp(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/Group
     * @param {Group} [group] Fresh group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1Group(group?: Group, options?: any): AxiosPromise<Group> {
      return localVarFp.createstorageHaloRunV1alpha1Group(group, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1Group(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletestorageHaloRunV1alpha1Group(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1Group(name: string, options?: any): AxiosPromise<Group> {
      return localVarFp.getstorageHaloRunV1alpha1Group(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List storage.halo.run/v1alpha1/Group
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1Group(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<GroupList> {
      return localVarFp
        .liststorageHaloRunV1alpha1Group(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update storage.halo.run/v1alpha1/Group
     * @param {string} name Name of group
     * @param {Group} [group] Updated group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1Group(name: string, group?: Group, options?: any): AxiosPromise<Group> {
      return localVarFp
        .updatestorageHaloRunV1alpha1Group(name, group, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StorageHaloRunV1alpha1GroupApi - object-oriented interface
 * @export
 * @class StorageHaloRunV1alpha1GroupApi
 * @extends {BaseAPI}
 */
export class StorageHaloRunV1alpha1GroupApi extends BaseAPI {
  /**
   * Create storage.halo.run/v1alpha1/Group
   * @param {Group} [group] Fresh group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1GroupApi
   */
  public createstorageHaloRunV1alpha1Group(group?: Group, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1GroupApiFp(this.configuration)
      .createstorageHaloRunV1alpha1Group(group, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete storage.halo.run/v1alpha1/Group
   * @param {string} name Name of group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1GroupApi
   */
  public deletestorageHaloRunV1alpha1Group(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1GroupApiFp(this.configuration)
      .deletestorageHaloRunV1alpha1Group(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get storage.halo.run/v1alpha1/Group
   * @param {string} name Name of group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1GroupApi
   */
  public getstorageHaloRunV1alpha1Group(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1GroupApiFp(this.configuration)
      .getstorageHaloRunV1alpha1Group(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List storage.halo.run/v1alpha1/Group
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1GroupApi
   */
  public liststorageHaloRunV1alpha1Group(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return StorageHaloRunV1alpha1GroupApiFp(this.configuration)
      .liststorageHaloRunV1alpha1Group(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update storage.halo.run/v1alpha1/Group
   * @param {string} name Name of group
   * @param {Group} [group] Updated group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1GroupApi
   */
  public updatestorageHaloRunV1alpha1Group(name: string, group?: Group, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1GroupApiFp(this.configuration)
      .updatestorageHaloRunV1alpha1Group(name, group, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StorageHaloRunV1alpha1PolicyApi - axios parameter creator
 * @export
 */
export const StorageHaloRunV1alpha1PolicyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create storage.halo.run/v1alpha1/Policy
     * @param {Policy} [policy] Fresh policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1Policy: async (
      policy?: Policy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1Policy: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletestorageHaloRunV1alpha1Policy', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1Policy: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getstorageHaloRunV1alpha1Policy', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List storage.halo.run/v1alpha1/Policy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1Policy: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policies`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {Policy} [policy] Updated policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1Policy: async (
      name: string,
      policy?: Policy,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatestorageHaloRunV1alpha1Policy', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policies/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StorageHaloRunV1alpha1PolicyApi - functional programming interface
 * @export
 */
export const StorageHaloRunV1alpha1PolicyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StorageHaloRunV1alpha1PolicyApiAxiosParamCreator(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/Policy
     * @param {Policy} [policy] Fresh policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createstorageHaloRunV1alpha1Policy(
      policy?: Policy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createstorageHaloRunV1alpha1Policy(policy, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletestorageHaloRunV1alpha1Policy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletestorageHaloRunV1alpha1Policy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getstorageHaloRunV1alpha1Policy(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getstorageHaloRunV1alpha1Policy(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List storage.halo.run/v1alpha1/Policy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async liststorageHaloRunV1alpha1Policy(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.liststorageHaloRunV1alpha1Policy(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {Policy} [policy] Updated policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatestorageHaloRunV1alpha1Policy(
      name: string,
      policy?: Policy,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatestorageHaloRunV1alpha1Policy(
        name,
        policy,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * StorageHaloRunV1alpha1PolicyApi - factory interface
 * @export
 */
export const StorageHaloRunV1alpha1PolicyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StorageHaloRunV1alpha1PolicyApiFp(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/Policy
     * @param {Policy} [policy] Fresh policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1Policy(policy?: Policy, options?: any): AxiosPromise<Policy> {
      return localVarFp.createstorageHaloRunV1alpha1Policy(policy, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1Policy(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletestorageHaloRunV1alpha1Policy(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1Policy(name: string, options?: any): AxiosPromise<Policy> {
      return localVarFp.getstorageHaloRunV1alpha1Policy(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List storage.halo.run/v1alpha1/Policy
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1Policy(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<PolicyList> {
      return localVarFp
        .liststorageHaloRunV1alpha1Policy(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update storage.halo.run/v1alpha1/Policy
     * @param {string} name Name of policy
     * @param {Policy} [policy] Updated policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1Policy(name: string, policy?: Policy, options?: any): AxiosPromise<Policy> {
      return localVarFp
        .updatestorageHaloRunV1alpha1Policy(name, policy, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StorageHaloRunV1alpha1PolicyApi - object-oriented interface
 * @export
 * @class StorageHaloRunV1alpha1PolicyApi
 * @extends {BaseAPI}
 */
export class StorageHaloRunV1alpha1PolicyApi extends BaseAPI {
  /**
   * Create storage.halo.run/v1alpha1/Policy
   * @param {Policy} [policy] Fresh policy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyApi
   */
  public createstorageHaloRunV1alpha1Policy(policy?: Policy, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1PolicyApiFp(this.configuration)
      .createstorageHaloRunV1alpha1Policy(policy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete storage.halo.run/v1alpha1/Policy
   * @param {string} name Name of policy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyApi
   */
  public deletestorageHaloRunV1alpha1Policy(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1PolicyApiFp(this.configuration)
      .deletestorageHaloRunV1alpha1Policy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get storage.halo.run/v1alpha1/Policy
   * @param {string} name Name of policy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyApi
   */
  public getstorageHaloRunV1alpha1Policy(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1PolicyApiFp(this.configuration)
      .getstorageHaloRunV1alpha1Policy(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List storage.halo.run/v1alpha1/Policy
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyApi
   */
  public liststorageHaloRunV1alpha1Policy(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return StorageHaloRunV1alpha1PolicyApiFp(this.configuration)
      .liststorageHaloRunV1alpha1Policy(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update storage.halo.run/v1alpha1/Policy
   * @param {string} name Name of policy
   * @param {Policy} [policy] Updated policy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyApi
   */
  public updatestorageHaloRunV1alpha1Policy(name: string, policy?: Policy, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1PolicyApiFp(this.configuration)
      .updatestorageHaloRunV1alpha1Policy(name, policy, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StorageHaloRunV1alpha1PolicyTemplateApi - axios parameter creator
 * @export
 */
export const StorageHaloRunV1alpha1PolicyTemplateApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create storage.halo.run/v1alpha1/PolicyTemplate
     * @param {PolicyTemplate} [policyTemplate] Fresh policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1PolicyTemplate: async (
      policyTemplate?: PolicyTemplate,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policytemplates`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(policyTemplate, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1PolicyTemplate: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletestorageHaloRunV1alpha1PolicyTemplate', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policytemplates/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1PolicyTemplate: async (
      name: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getstorageHaloRunV1alpha1PolicyTemplate', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policytemplates/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List storage.halo.run/v1alpha1/PolicyTemplate
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1PolicyTemplate: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policytemplates`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {PolicyTemplate} [policyTemplate] Updated policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1PolicyTemplate: async (
      name: string,
      policyTemplate?: PolicyTemplate,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatestorageHaloRunV1alpha1PolicyTemplate', 'name', name)
      const localVarPath = `/apis/storage.halo.run/v1alpha1/policytemplates/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(policyTemplate, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StorageHaloRunV1alpha1PolicyTemplateApi - functional programming interface
 * @export
 */
export const StorageHaloRunV1alpha1PolicyTemplateApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StorageHaloRunV1alpha1PolicyTemplateApiAxiosParamCreator(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/PolicyTemplate
     * @param {PolicyTemplate} [policyTemplate] Fresh policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createstorageHaloRunV1alpha1PolicyTemplate(
      policyTemplate?: PolicyTemplate,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyTemplate>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createstorageHaloRunV1alpha1PolicyTemplate(
        policyTemplate,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletestorageHaloRunV1alpha1PolicyTemplate(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletestorageHaloRunV1alpha1PolicyTemplate(
        name,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getstorageHaloRunV1alpha1PolicyTemplate(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyTemplate>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getstorageHaloRunV1alpha1PolicyTemplate(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List storage.halo.run/v1alpha1/PolicyTemplate
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async liststorageHaloRunV1alpha1PolicyTemplate(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyTemplateList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.liststorageHaloRunV1alpha1PolicyTemplate(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {PolicyTemplate} [policyTemplate] Updated policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatestorageHaloRunV1alpha1PolicyTemplate(
      name: string,
      policyTemplate?: PolicyTemplate,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyTemplate>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatestorageHaloRunV1alpha1PolicyTemplate(
        name,
        policyTemplate,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * StorageHaloRunV1alpha1PolicyTemplateApi - factory interface
 * @export
 */
export const StorageHaloRunV1alpha1PolicyTemplateApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StorageHaloRunV1alpha1PolicyTemplateApiFp(configuration)
  return {
    /**
     * Create storage.halo.run/v1alpha1/PolicyTemplate
     * @param {PolicyTemplate} [policyTemplate] Fresh policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createstorageHaloRunV1alpha1PolicyTemplate(
      policyTemplate?: PolicyTemplate,
      options?: any,
    ): AxiosPromise<PolicyTemplate> {
      return localVarFp
        .createstorageHaloRunV1alpha1PolicyTemplate(policyTemplate, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletestorageHaloRunV1alpha1PolicyTemplate(name: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deletestorageHaloRunV1alpha1PolicyTemplate(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getstorageHaloRunV1alpha1PolicyTemplate(name: string, options?: any): AxiosPromise<PolicyTemplate> {
      return localVarFp
        .getstorageHaloRunV1alpha1PolicyTemplate(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List storage.halo.run/v1alpha1/PolicyTemplate
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    liststorageHaloRunV1alpha1PolicyTemplate(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<PolicyTemplateList> {
      return localVarFp
        .liststorageHaloRunV1alpha1PolicyTemplate(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update storage.halo.run/v1alpha1/PolicyTemplate
     * @param {string} name Name of policytemplate
     * @param {PolicyTemplate} [policyTemplate] Updated policytemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatestorageHaloRunV1alpha1PolicyTemplate(
      name: string,
      policyTemplate?: PolicyTemplate,
      options?: any,
    ): AxiosPromise<PolicyTemplate> {
      return localVarFp
        .updatestorageHaloRunV1alpha1PolicyTemplate(name, policyTemplate, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StorageHaloRunV1alpha1PolicyTemplateApi - object-oriented interface
 * @export
 * @class StorageHaloRunV1alpha1PolicyTemplateApi
 * @extends {BaseAPI}
 */
export class StorageHaloRunV1alpha1PolicyTemplateApi extends BaseAPI {
  /**
   * Create storage.halo.run/v1alpha1/PolicyTemplate
   * @param {PolicyTemplate} [policyTemplate] Fresh policytemplate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyTemplateApi
   */
  public createstorageHaloRunV1alpha1PolicyTemplate(policyTemplate?: PolicyTemplate, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1PolicyTemplateApiFp(this.configuration)
      .createstorageHaloRunV1alpha1PolicyTemplate(policyTemplate, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete storage.halo.run/v1alpha1/PolicyTemplate
   * @param {string} name Name of policytemplate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyTemplateApi
   */
  public deletestorageHaloRunV1alpha1PolicyTemplate(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1PolicyTemplateApiFp(this.configuration)
      .deletestorageHaloRunV1alpha1PolicyTemplate(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get storage.halo.run/v1alpha1/PolicyTemplate
   * @param {string} name Name of policytemplate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyTemplateApi
   */
  public getstorageHaloRunV1alpha1PolicyTemplate(name: string, options?: AxiosRequestConfig) {
    return StorageHaloRunV1alpha1PolicyTemplateApiFp(this.configuration)
      .getstorageHaloRunV1alpha1PolicyTemplate(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List storage.halo.run/v1alpha1/PolicyTemplate
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyTemplateApi
   */
  public liststorageHaloRunV1alpha1PolicyTemplate(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return StorageHaloRunV1alpha1PolicyTemplateApiFp(this.configuration)
      .liststorageHaloRunV1alpha1PolicyTemplate(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update storage.halo.run/v1alpha1/PolicyTemplate
   * @param {string} name Name of policytemplate
   * @param {PolicyTemplate} [policyTemplate] Updated policytemplate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StorageHaloRunV1alpha1PolicyTemplateApi
   */
  public updatestorageHaloRunV1alpha1PolicyTemplate(
    name: string,
    policyTemplate?: PolicyTemplate,
    options?: AxiosRequestConfig,
  ) {
    return StorageHaloRunV1alpha1PolicyTemplateApiFp(this.configuration)
      .updatestorageHaloRunV1alpha1PolicyTemplate(name, policyTemplate, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - axios parameter creator
 * @export
 */
export const ThemeHaloRunV1alpha1ThemeApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create theme.halo.run/v1alpha1/Theme
     * @param {Theme} [theme] Fresh theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createthemeHaloRunV1alpha1Theme: async (theme?: Theme, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(theme, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletethemeHaloRunV1alpha1Theme: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletethemeHaloRunV1alpha1Theme', 'name', name)
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getthemeHaloRunV1alpha1Theme: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getthemeHaloRunV1alpha1Theme', 'name', name)
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List theme.halo.run/v1alpha1/Theme
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listthemeHaloRunV1alpha1Theme: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {Theme} [theme] Updated theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatethemeHaloRunV1alpha1Theme: async (
      name: string,
      theme?: Theme,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatethemeHaloRunV1alpha1Theme', 'name', name)
      const localVarPath = `/apis/theme.halo.run/v1alpha1/themes/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(theme, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - functional programming interface
 * @export
 */
export const ThemeHaloRunV1alpha1ThemeApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ThemeHaloRunV1alpha1ThemeApiAxiosParamCreator(configuration)
  return {
    /**
     * Create theme.halo.run/v1alpha1/Theme
     * @param {Theme} [theme] Fresh theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createthemeHaloRunV1alpha1Theme(
      theme?: Theme,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createthemeHaloRunV1alpha1Theme(theme, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletethemeHaloRunV1alpha1Theme(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletethemeHaloRunV1alpha1Theme(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getthemeHaloRunV1alpha1Theme(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getthemeHaloRunV1alpha1Theme(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List theme.halo.run/v1alpha1/Theme
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listthemeHaloRunV1alpha1Theme(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listthemeHaloRunV1alpha1Theme(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {Theme} [theme] Updated theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatethemeHaloRunV1alpha1Theme(
      name: string,
      theme?: Theme,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Theme>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatethemeHaloRunV1alpha1Theme(name, theme, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - factory interface
 * @export
 */
export const ThemeHaloRunV1alpha1ThemeApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ThemeHaloRunV1alpha1ThemeApiFp(configuration)
  return {
    /**
     * Create theme.halo.run/v1alpha1/Theme
     * @param {Theme} [theme] Fresh theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createthemeHaloRunV1alpha1Theme(theme?: Theme, options?: any): AxiosPromise<Theme> {
      return localVarFp.createthemeHaloRunV1alpha1Theme(theme, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletethemeHaloRunV1alpha1Theme(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletethemeHaloRunV1alpha1Theme(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getthemeHaloRunV1alpha1Theme(name: string, options?: any): AxiosPromise<Theme> {
      return localVarFp.getthemeHaloRunV1alpha1Theme(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List theme.halo.run/v1alpha1/Theme
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listthemeHaloRunV1alpha1Theme(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<ThemeList> {
      return localVarFp
        .listthemeHaloRunV1alpha1Theme(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update theme.halo.run/v1alpha1/Theme
     * @param {string} name Name of theme
     * @param {Theme} [theme] Updated theme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatethemeHaloRunV1alpha1Theme(name: string, theme?: Theme, options?: any): AxiosPromise<Theme> {
      return localVarFp
        .updatethemeHaloRunV1alpha1Theme(name, theme, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ThemeHaloRunV1alpha1ThemeApi - object-oriented interface
 * @export
 * @class ThemeHaloRunV1alpha1ThemeApi
 * @extends {BaseAPI}
 */
export class ThemeHaloRunV1alpha1ThemeApi extends BaseAPI {
  /**
   * Create theme.halo.run/v1alpha1/Theme
   * @param {Theme} [theme] Fresh theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public createthemeHaloRunV1alpha1Theme(theme?: Theme, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .createthemeHaloRunV1alpha1Theme(theme, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete theme.halo.run/v1alpha1/Theme
   * @param {string} name Name of theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public deletethemeHaloRunV1alpha1Theme(name: string, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .deletethemeHaloRunV1alpha1Theme(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get theme.halo.run/v1alpha1/Theme
   * @param {string} name Name of theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public getthemeHaloRunV1alpha1Theme(name: string, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .getthemeHaloRunV1alpha1Theme(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List theme.halo.run/v1alpha1/Theme
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public listthemeHaloRunV1alpha1Theme(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .listthemeHaloRunV1alpha1Theme(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update theme.halo.run/v1alpha1/Theme
   * @param {string} name Name of theme
   * @param {Theme} [theme] Updated theme
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ThemeHaloRunV1alpha1ThemeApi
   */
  public updatethemeHaloRunV1alpha1Theme(name: string, theme?: Theme, options?: AxiosRequestConfig) {
    return ThemeHaloRunV1alpha1ThemeApiFp(this.configuration)
      .updatethemeHaloRunV1alpha1Theme(name, theme, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1ConfigMapApi - axios parameter creator
 * @export
 */
export const V1alpha1ConfigMapApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap: async (configMap?: ConfigMap, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/configmaps`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap: async (
      name: string,
      configMap?: ConfigMap,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1ConfigMap', 'name', name)
      const localVarPath = `/api/v1alpha1/configmaps/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(configMap, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1ConfigMapApi - functional programming interface
 * @export
 */
export const V1alpha1ConfigMapApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1ConfigMapApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1ConfigMap(
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1ConfigMap(configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1ConfigMap(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1ConfigMap(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1ConfigMap(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMapList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1ConfigMap(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1ConfigMap(
      name: string,
      configMap?: ConfigMap,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigMap>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1ConfigMap(name, configMap, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1ConfigMapApi - factory interface
 * @export
 */
export const V1alpha1ConfigMapApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1ConfigMapApiFp(configuration)
  return {
    /**
     * Create v1alpha1/ConfigMap
     * @param {ConfigMap} [configMap] Fresh configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1ConfigMap(configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.createv1alpha1ConfigMap(configMap, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1ConfigMap(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1ConfigMap(name: string, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.getv1alpha1ConfigMap(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/ConfigMap
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1ConfigMap(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<ConfigMapList> {
      return localVarFp
        .listv1alpha1ConfigMap(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/ConfigMap
     * @param {string} name Name of configmap
     * @param {ConfigMap} [configMap] Updated configmap
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: any): AxiosPromise<ConfigMap> {
      return localVarFp.updatev1alpha1ConfigMap(name, configMap, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1ConfigMapApi - object-oriented interface
 * @export
 * @class V1alpha1ConfigMapApi
 * @extends {BaseAPI}
 */
export class V1alpha1ConfigMapApi extends BaseAPI {
  /**
   * Create v1alpha1/ConfigMap
   * @param {ConfigMap} [configMap] Fresh configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public createv1alpha1ConfigMap(configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .createv1alpha1ConfigMap(configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public deletev1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .deletev1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public getv1alpha1ConfigMap(name: string, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .getv1alpha1ConfigMap(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/ConfigMap
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public listv1alpha1ConfigMap(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .listv1alpha1ConfigMap(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/ConfigMap
   * @param {string} name Name of configmap
   * @param {ConfigMap} [configMap] Updated configmap
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1ConfigMapApi
   */
  public updatev1alpha1ConfigMap(name: string, configMap?: ConfigMap, options?: AxiosRequestConfig) {
    return V1alpha1ConfigMapApiFp(this.configuration)
      .updatev1alpha1ConfigMap(name, configMap, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1MenuApi - axios parameter creator
 * @export
 */
export const V1alpha1MenuApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Menu
     * @param {Menu} [menu] Fresh menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Menu: async (menu?: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menus`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Menu: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Menu', 'name', name)
      const localVarPath = `/api/v1alpha1/menus/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Menu: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Menu', 'name', name)
      const localVarPath = `/api/v1alpha1/menus/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Menu
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Menu: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menus`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {Menu} [menu] Updated menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Menu: async (name: string, menu?: Menu, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Menu', 'name', name)
      const localVarPath = `/api/v1alpha1/menus/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menu, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1MenuApi - functional programming interface
 * @export
 */
export const V1alpha1MenuApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1MenuApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Menu
     * @param {Menu} [menu] Fresh menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Menu(
      menu?: Menu,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Menu(menu, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Menu(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Menu(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Menu(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Menu(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Menu
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Menu(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Menu(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {Menu} [menu] Updated menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Menu(
      name: string,
      menu?: Menu,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Menu>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Menu(name, menu, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1MenuApi - factory interface
 * @export
 */
export const V1alpha1MenuApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1MenuApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Menu
     * @param {Menu} [menu] Fresh menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Menu(menu?: Menu, options?: any): AxiosPromise<Menu> {
      return localVarFp.createv1alpha1Menu(menu, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Menu(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Menu(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Menu(name: string, options?: any): AxiosPromise<Menu> {
      return localVarFp.getv1alpha1Menu(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Menu
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Menu(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<MenuList> {
      return localVarFp
        .listv1alpha1Menu(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Menu
     * @param {string} name Name of menu
     * @param {Menu} [menu] Updated menu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Menu(name: string, menu?: Menu, options?: any): AxiosPromise<Menu> {
      return localVarFp.updatev1alpha1Menu(name, menu, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1MenuApi - object-oriented interface
 * @export
 * @class V1alpha1MenuApi
 * @extends {BaseAPI}
 */
export class V1alpha1MenuApi extends BaseAPI {
  /**
   * Create v1alpha1/Menu
   * @param {Menu} [menu] Fresh menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public createv1alpha1Menu(menu?: Menu, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .createv1alpha1Menu(menu, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Menu
   * @param {string} name Name of menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public deletev1alpha1Menu(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .deletev1alpha1Menu(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Menu
   * @param {string} name Name of menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public getv1alpha1Menu(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .getv1alpha1Menu(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Menu
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public listv1alpha1Menu(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1MenuApiFp(this.configuration)
      .listv1alpha1Menu(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Menu
   * @param {string} name Name of menu
   * @param {Menu} [menu] Updated menu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuApi
   */
  public updatev1alpha1Menu(name: string, menu?: Menu, options?: AxiosRequestConfig) {
    return V1alpha1MenuApiFp(this.configuration)
      .updatev1alpha1Menu(name, menu, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1MenuItemApi - axios parameter creator
 * @export
 */
export const V1alpha1MenuItemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/MenuItem
     * @param {MenuItem} [menuItem] Fresh menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1MenuItem: async (menuItem?: MenuItem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menuitems`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menuItem, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1MenuItem: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1MenuItem', 'name', name)
      const localVarPath = `/api/v1alpha1/menuitems/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1MenuItem: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1MenuItem', 'name', name)
      const localVarPath = `/api/v1alpha1/menuitems/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/MenuItem
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1MenuItem: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/menuitems`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {MenuItem} [menuItem] Updated menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1MenuItem: async (
      name: string,
      menuItem?: MenuItem,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1MenuItem', 'name', name)
      const localVarPath = `/api/v1alpha1/menuitems/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(menuItem, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1MenuItemApi - functional programming interface
 * @export
 */
export const V1alpha1MenuItemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1MenuItemApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/MenuItem
     * @param {MenuItem} [menuItem] Fresh menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1MenuItem(
      menuItem?: MenuItem,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1MenuItem(menuItem, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1MenuItem(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1MenuItem(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1MenuItem(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1MenuItem(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/MenuItem
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1MenuItem(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItemList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1MenuItem(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {MenuItem} [menuItem] Updated menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1MenuItem(
      name: string,
      menuItem?: MenuItem,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MenuItem>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1MenuItem(name, menuItem, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1MenuItemApi - factory interface
 * @export
 */
export const V1alpha1MenuItemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1MenuItemApiFp(configuration)
  return {
    /**
     * Create v1alpha1/MenuItem
     * @param {MenuItem} [menuItem] Fresh menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1MenuItem(menuItem?: MenuItem, options?: any): AxiosPromise<MenuItem> {
      return localVarFp.createv1alpha1MenuItem(menuItem, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1MenuItem(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1MenuItem(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1MenuItem(name: string, options?: any): AxiosPromise<MenuItem> {
      return localVarFp.getv1alpha1MenuItem(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/MenuItem
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1MenuItem(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<MenuItemList> {
      return localVarFp
        .listv1alpha1MenuItem(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/MenuItem
     * @param {string} name Name of menuitem
     * @param {MenuItem} [menuItem] Updated menuitem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1MenuItem(name: string, menuItem?: MenuItem, options?: any): AxiosPromise<MenuItem> {
      return localVarFp.updatev1alpha1MenuItem(name, menuItem, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1MenuItemApi - object-oriented interface
 * @export
 * @class V1alpha1MenuItemApi
 * @extends {BaseAPI}
 */
export class V1alpha1MenuItemApi extends BaseAPI {
  /**
   * Create v1alpha1/MenuItem
   * @param {MenuItem} [menuItem] Fresh menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public createv1alpha1MenuItem(menuItem?: MenuItem, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .createv1alpha1MenuItem(menuItem, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/MenuItem
   * @param {string} name Name of menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public deletev1alpha1MenuItem(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .deletev1alpha1MenuItem(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/MenuItem
   * @param {string} name Name of menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public getv1alpha1MenuItem(name: string, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .getv1alpha1MenuItem(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/MenuItem
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public listv1alpha1MenuItem(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .listv1alpha1MenuItem(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/MenuItem
   * @param {string} name Name of menuitem
   * @param {MenuItem} [menuItem] Updated menuitem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1MenuItemApi
   */
  public updatev1alpha1MenuItem(name: string, menuItem?: MenuItem, options?: AxiosRequestConfig) {
    return V1alpha1MenuItemApiFp(this.configuration)
      .updatev1alpha1MenuItem(name, menuItem, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - axios parameter creator
 * @export
 */
export const V1alpha1PersonalAccessTokenApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken: async (
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/personalaccesstokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken: async (
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1PersonalAccessToken', 'name', name)
      const localVarPath = `/api/v1alpha1/personalaccesstokens/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(personalAccessToken, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - functional programming interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1PersonalAccessTokenApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1PersonalAccessToken(
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1PersonalAccessToken(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1PersonalAccessToken(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessTokenList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1PersonalAccessToken(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalAccessToken>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1PersonalAccessToken(
        name,
        personalAccessToken,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - factory interface
 * @export
 */
export const V1alpha1PersonalAccessTokenApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1PersonalAccessTokenApiFp(configuration)
  return {
    /**
     * Create v1alpha1/PersonalAccessToken
     * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1PersonalAccessToken(
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .createv1alpha1PersonalAccessToken(personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1PersonalAccessToken(name: string, options?: any): AxiosPromise<PersonalAccessToken> {
      return localVarFp.getv1alpha1PersonalAccessToken(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/PersonalAccessToken
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1PersonalAccessToken(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<PersonalAccessTokenList> {
      return localVarFp
        .listv1alpha1PersonalAccessToken(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/PersonalAccessToken
     * @param {string} name Name of personalaccesstoken
     * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1PersonalAccessToken(
      name: string,
      personalAccessToken?: PersonalAccessToken,
      options?: any,
    ): AxiosPromise<PersonalAccessToken> {
      return localVarFp
        .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1PersonalAccessTokenApi - object-oriented interface
 * @export
 * @class V1alpha1PersonalAccessTokenApi
 * @extends {BaseAPI}
 */
export class V1alpha1PersonalAccessTokenApi extends BaseAPI {
  /**
   * Create v1alpha1/PersonalAccessToken
   * @param {PersonalAccessToken} [personalAccessToken] Fresh personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public createv1alpha1PersonalAccessToken(personalAccessToken?: PersonalAccessToken, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .createv1alpha1PersonalAccessToken(personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public deletev1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .deletev1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public getv1alpha1PersonalAccessToken(name: string, options?: AxiosRequestConfig) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .getv1alpha1PersonalAccessToken(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/PersonalAccessToken
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public listv1alpha1PersonalAccessToken(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .listv1alpha1PersonalAccessToken(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/PersonalAccessToken
   * @param {string} name Name of personalaccesstoken
   * @param {PersonalAccessToken} [personalAccessToken] Updated personalaccesstoken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1PersonalAccessTokenApi
   */
  public updatev1alpha1PersonalAccessToken(
    name: string,
    personalAccessToken?: PersonalAccessToken,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1PersonalAccessTokenApiFp(this.configuration)
      .updatev1alpha1PersonalAccessToken(name, personalAccessToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role: async (role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/roles`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role: async (name: string, role?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Role', 'name', name)
      const localVarPath = `/api/v1alpha1/roles/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleApi - functional programming interface
 * @export
 */
export const V1alpha1RoleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Role(
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Role(role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Role(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Role(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Role(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Role(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Role(
      name: string,
      role?: Role,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Role(name, role, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleApi - factory interface
 * @export
 */
export const V1alpha1RoleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Role
     * @param {Role} [role] Fresh role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Role(role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.createv1alpha1Role(role, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Role(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Role
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Role(name: string, options?: any): AxiosPromise<Role> {
      return localVarFp.getv1alpha1Role(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Role
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Role(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<RoleList> {
      return localVarFp
        .listv1alpha1Role(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Role
     * @param {string} name Name of role
     * @param {Role} [role] Updated role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Role(name: string, role?: Role, options?: any): AxiosPromise<Role> {
      return localVarFp.updatev1alpha1Role(name, role, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleApi - object-oriented interface
 * @export
 * @class V1alpha1RoleApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleApi extends BaseAPI {
  /**
   * Create v1alpha1/Role
   * @param {Role} [role] Fresh role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public createv1alpha1Role(role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .createv1alpha1Role(role, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public deletev1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .deletev1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Role
   * @param {string} name Name of role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public getv1alpha1Role(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .getv1alpha1Role(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Role
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public listv1alpha1Role(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1RoleApiFp(this.configuration)
      .listv1alpha1Role(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Role
   * @param {string} name Name of role
   * @param {Role} [role] Updated role
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleApi
   */
  public updatev1alpha1Role(name: string, role?: Role, options?: AxiosRequestConfig) {
    return V1alpha1RoleApiFp(this.configuration)
      .updatev1alpha1Role(name, role, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1RoleBindingApi - axios parameter creator
 * @export
 */
export const V1alpha1RoleBindingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding: async (
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/rolebindings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding: async (
      name: string,
      roleBinding?: RoleBinding,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1RoleBinding', 'name', name)
      const localVarPath = `/api/v1alpha1/rolebindings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(roleBinding, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1RoleBindingApi - functional programming interface
 * @export
 */
export const V1alpha1RoleBindingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1RoleBindingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1RoleBinding(
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1RoleBinding(roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1RoleBinding(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1RoleBinding(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1RoleBinding(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBindingList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1RoleBinding(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1RoleBinding(
      name: string,
      roleBinding?: RoleBinding,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleBinding>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1RoleBinding(name, roleBinding, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1RoleBindingApi - factory interface
 * @export
 */
export const V1alpha1RoleBindingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1RoleBindingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/RoleBinding
     * @param {RoleBinding} [roleBinding] Fresh rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.createv1alpha1RoleBinding(roleBinding, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1RoleBinding(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1RoleBinding(name: string, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp.getv1alpha1RoleBinding(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/RoleBinding
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1RoleBinding(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<RoleBindingList> {
      return localVarFp
        .listv1alpha1RoleBinding(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/RoleBinding
     * @param {string} name Name of rolebinding
     * @param {RoleBinding} [roleBinding] Updated rolebinding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: any): AxiosPromise<RoleBinding> {
      return localVarFp
        .updatev1alpha1RoleBinding(name, roleBinding, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1RoleBindingApi - object-oriented interface
 * @export
 * @class V1alpha1RoleBindingApi
 * @extends {BaseAPI}
 */
export class V1alpha1RoleBindingApi extends BaseAPI {
  /**
   * Create v1alpha1/RoleBinding
   * @param {RoleBinding} [roleBinding] Fresh rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public createv1alpha1RoleBinding(roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .createv1alpha1RoleBinding(roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public deletev1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .deletev1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public getv1alpha1RoleBinding(name: string, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .getv1alpha1RoleBinding(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/RoleBinding
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public listv1alpha1RoleBinding(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .listv1alpha1RoleBinding(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/RoleBinding
   * @param {string} name Name of rolebinding
   * @param {RoleBinding} [roleBinding] Updated rolebinding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1RoleBindingApi
   */
  public updatev1alpha1RoleBinding(name: string, roleBinding?: RoleBinding, options?: AxiosRequestConfig) {
    return V1alpha1RoleBindingApiFp(this.configuration)
      .updatev1alpha1RoleBinding(name, roleBinding, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1SettingApi - axios parameter creator
 * @export
 */
export const V1alpha1SettingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting: async (setting?: Setting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/settings`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting: async (
      name: string,
      setting?: Setting,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1Setting', 'name', name)
      const localVarPath = `/api/v1alpha1/settings/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(setting, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1SettingApi - functional programming interface
 * @export
 */
export const V1alpha1SettingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1SettingApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1Setting(
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1Setting(setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1Setting(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1Setting(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1Setting(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1Setting(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1Setting(
      name: string,
      setting?: Setting,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1Setting(name, setting, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1SettingApi - factory interface
 * @export
 */
export const V1alpha1SettingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1SettingApiFp(configuration)
  return {
    /**
     * Create v1alpha1/Setting
     * @param {Setting} [setting] Fresh setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1Setting(setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.createv1alpha1Setting(setting, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1Setting(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1Setting(name: string, options?: any): AxiosPromise<Setting> {
      return localVarFp.getv1alpha1Setting(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/Setting
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1Setting(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<SettingList> {
      return localVarFp
        .listv1alpha1Setting(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/Setting
     * @param {string} name Name of setting
     * @param {Setting} [setting] Updated setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1Setting(name: string, setting?: Setting, options?: any): AxiosPromise<Setting> {
      return localVarFp.updatev1alpha1Setting(name, setting, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1SettingApi - object-oriented interface
 * @export
 * @class V1alpha1SettingApi
 * @extends {BaseAPI}
 */
export class V1alpha1SettingApi extends BaseAPI {
  /**
   * Create v1alpha1/Setting
   * @param {Setting} [setting] Fresh setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public createv1alpha1Setting(setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .createv1alpha1Setting(setting, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public deletev1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .deletev1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public getv1alpha1Setting(name: string, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .getv1alpha1Setting(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/Setting
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public listv1alpha1Setting(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1SettingApiFp(this.configuration)
      .listv1alpha1Setting(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/Setting
   * @param {string} name Name of setting
   * @param {Setting} [setting] Updated setting
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1SettingApi
   */
  public updatev1alpha1Setting(name: string, setting?: Setting, options?: AxiosRequestConfig) {
    return V1alpha1SettingApiFp(this.configuration)
      .updatev1alpha1Setting(name, setting, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * V1alpha1UserApi - axios parameter creator
 * @export
 */
export const V1alpha1UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User: async (user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('deletev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getv1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User: async (
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1alpha1/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (labelSelector) {
        localVarQueryParameter['labelSelector'] = labelSelector
      }

      if (fieldSelector) {
        localVarQueryParameter['fieldSelector'] = fieldSelector
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User: async (name: string, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      assertParamExists('updatev1alpha1User', 'name', name)
      const localVarPath = `/api/v1alpha1/users/{name}`.replace(`{${'name'}}`, encodeURIComponent(String(name)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BasicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      // authentication BearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers }
      localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * V1alpha1UserApi - functional programming interface
 * @export
 */
export const V1alpha1UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V1alpha1UserApiAxiosParamCreator(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createv1alpha1User(
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createv1alpha1User(user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletev1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletev1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getv1alpha1User(
      name: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getv1alpha1User(name, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listv1alpha1User(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listv1alpha1User(
        page,
        size,
        labelSelector,
        fieldSelector,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatev1alpha1User(
      name: string,
      user?: User,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatev1alpha1User(name, user, options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * V1alpha1UserApi - factory interface
 * @export
 */
export const V1alpha1UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V1alpha1UserApiFp(configuration)
  return {
    /**
     * Create v1alpha1/User
     * @param {User} [user] Fresh user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createv1alpha1User(user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.createv1alpha1User(user, options).then((request) => request(axios, basePath))
    },
    /**
     * Delete v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletev1alpha1User(name: string, options?: any): AxiosPromise<void> {
      return localVarFp.deletev1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * Get v1alpha1/User
     * @param {string} name Name of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getv1alpha1User(name: string, options?: any): AxiosPromise<User> {
      return localVarFp.getv1alpha1User(name, options).then((request) => request(axios, basePath))
    },
    /**
     * List v1alpha1/User
     * @param {number} [page] The page number. Zero indicates no page.
     * @param {number} [size] Size of one page. Zero indicates no limit.
     * @param {Array<string>} [labelSelector] Label selector for filtering.
     * @param {Array<string>} [fieldSelector] Field selector for filtering.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listv1alpha1User(
      page?: number,
      size?: number,
      labelSelector?: Array<string>,
      fieldSelector?: Array<string>,
      options?: any,
    ): AxiosPromise<UserList> {
      return localVarFp
        .listv1alpha1User(page, size, labelSelector, fieldSelector, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update v1alpha1/User
     * @param {string} name Name of user
     * @param {User} [user] Updated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatev1alpha1User(name: string, user?: User, options?: any): AxiosPromise<User> {
      return localVarFp.updatev1alpha1User(name, user, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * V1alpha1UserApi - object-oriented interface
 * @export
 * @class V1alpha1UserApi
 * @extends {BaseAPI}
 */
export class V1alpha1UserApi extends BaseAPI {
  /**
   * Create v1alpha1/User
   * @param {User} [user] Fresh user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public createv1alpha1User(user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .createv1alpha1User(user, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public deletev1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .deletev1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get v1alpha1/User
   * @param {string} name Name of user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public getv1alpha1User(name: string, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .getv1alpha1User(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List v1alpha1/User
   * @param {number} [page] The page number. Zero indicates no page.
   * @param {number} [size] Size of one page. Zero indicates no limit.
   * @param {Array<string>} [labelSelector] Label selector for filtering.
   * @param {Array<string>} [fieldSelector] Field selector for filtering.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public listv1alpha1User(
    page?: number,
    size?: number,
    labelSelector?: Array<string>,
    fieldSelector?: Array<string>,
    options?: AxiosRequestConfig,
  ) {
    return V1alpha1UserApiFp(this.configuration)
      .listv1alpha1User(page, size, labelSelector, fieldSelector, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update v1alpha1/User
   * @param {string} name Name of user
   * @param {User} [user] Updated user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V1alpha1UserApi
   */
  public updatev1alpha1User(name: string, user?: User, options?: AxiosRequestConfig) {
    return V1alpha1UserApiFp(this.configuration)
      .updatev1alpha1User(name, user, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
